[prepare_database]
CREATE TABLE KeyValue
AS
SELECT 1 AS key, "value1" AS value
UNION ALL
SELECT 2, "value2"
UNION ALL
SELECT 3, "value1"
--
ARRAY<STRUCT<key INT64, value STRING>>[
  {1, "value1"},
  {2, "value2"},
  {3, "value1"}
]
==

# Tree structure:
# 1
# |- 2
#   |- 3
# |- 4
#   |- 5
#   |- 6
[prepare_database]
CREATE TABLE TreeNodes
AS
SELECT 1 AS node_id, NULL AS parent_id
UNION ALL
SELECT 2, 1
UNION ALL
SELECT 3, 2
UNION ALL
SELECT 4, 1
UNION ALL
SELECT 5, 4
UNION ALL
SELECT 6, 4
--
ARRAY<STRUCT<node_id INT64, parent_id INT64>>[
  {1, NULL},
  {2, 1},
  {3, 2},
  {4, 1},
  {5, 4},
  {6, 4}
]
==

[default required_features=PIPES,PIPE_RECURSIVE_UNION]
[name=basic_subpipeline]
from keyvalue
|> recursive union all (
  |> where key < 3
  |> select key + 1 as key, value
) as t
|> select t.key, t.value
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "value2"},
  {3, "value1"},
  {3, "value2"},
  {2, "value1"},
  {3, "value1"}
]
==

[name=basic_subpipeline_without_alias]
from keyvalue
|> recursive union all (
  |> where key < 3
  |> select key + 1 as key, value
)
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "value2"},
  {3, "value1"},
  {3, "value2"},
  {2, "value1"},
  {3, "value1"}
]
==

[name=basic_subquery]
from keyvalue
|> recursive union all (
  select key + 1 as key, value
  from t
  where key < 3
) as t
|> select t.key, t.value
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "value2"},
  {3, "value1"},
  {3, "value2"},
  {2, "value1"},
  {3, "value1"}
]
==

[name=basic_subpipeline_with_other_operators]
from keyvalue
|> select key
|> recursive union distinct (
  |> select key + 1 as key
  |> where key < 5
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{2}, {1}, {3}, {4}]
==

[name=basic_subquery_with_other_operators]
from keyvalue
|> select key
|> recursive union distinct (
  from t
  |> select key + 1 as key
  |> where key < 5
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{2}, {1}, {3}, {4}]
==

[name=subquery_two_pipe_recursive_union_in_a_row]
from keyvalue
|> recursive union distinct (
  from t
  |> where key = 1
) as t
|> recursive union all (
  from keyvalue
  |> join t using (key)
  |> select key + 1 as key, t.value
  |> where key < 3
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "value2"},
  {3, "value1"},
  {2, "value1"}
]
==

[name=subpipeline_two_pipe_recursive_union_in_a_row]
from keyvalue
|> recursive union distinct (
  |> where key = 1
) as t
|> recursive union all (
  |> select key + 1 as key, t.value
  |> where key < 3
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "value2"},
  {3, "value1"},
  {2, "value1"}
]
==

# Type coercion: int32 -> int64
[name=subquery_type_coercion]
from keyvalue
|> recursive union distinct (
  from t
  |> select cast(key + 1 as int32) as key, value
  |> where key < 3
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {2, "value2"},
  {1, "value1"},
  {3, "value1"},
  {2, "value1"}
]
==

[name=subpipeline_type_coercion]
from keyvalue
|> recursive union distinct (
  |> select cast(key + 1 as int32) as key, value
  |> where key < 3
)
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {2, "value2"},
  {1, "value1"},
  {3, "value1"},
  {2, "value1"}
]
==

# Literal coercion: null -> string
[name=subquery_literal_coercion]
from keyvalue
|> recursive union distinct (
  from t
  |> set key = key + 1
  |> where key < 3
  |> select key, null
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {2, "value2"},
  {1, "value1"},
  {3, "value1"},
  {2, NULL}
]
==

# Literal coercion: null -> string
[name=subpipeline_literal_coercion]
from keyvalue
|> recursive union distinct (
  |> set key = key + 1
  |> where key < 3
  |> select key, null
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {2, "value2"},
  {1, "value1"},
  {3, "value1"},
  {2, NULL}
]
==

[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE]
[name=subquery_with_with_recursive]
with recursive t as (
  select 1 as col
  |> union all (
    from t
    |> recursive union all (
      from t
      |> select col + 1 as col
      |> where col < 3
    ) as t
    |> select col + 1 as col
    |> where col < 4
  )
)
from t;
--
ARRAY<STRUCT<col INT64>>[unknown order:{1}, {3}, {2}, {3}]
==

[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE]
[name=subpipeline_with_with_recursive]
with recursive t as (
  select 1 as col
  |> union all (
    from t
    |> recursive union all (
      |> select col + 1 as col
      |> where col < 3
    )
    |> select col + 1 as col
    |> where col < 4
  )
)
from t;
--
ARRAY<STRUCT<col INT64>>[unknown order:{1}, {3}, {2}, {3}]
==

[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE,WITH_ON_SUBQUERY]
[name=subquery_with_recursive_used_inside_pipe_recursive_union]
select 1 as key
|> recursive union all (
  with recursive s as (
    select 1 as key
    |> union all (
      from s
      |> set key = key + 1
      |> where key < 3
    )
  )
  from s
  |> inner join t using (key)
  |> set key = key + 1
  |> where key < 4
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {2}, {3}]
==

[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE,WITH_ON_SUBQUERY]
[name=subpipeline_with_recursive_used_inside_pipe_recursive_union]
select 1 as key
|> recursive union all (
  |> inner join (
    with recursive s as (
      select 1 as key
      |> union all (
        from s
        |> set key = key + 1
        |> where key < 3
      )
    )
    from s
  ) using (key)
  |> set key = key + 1
  |> where key < 4
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {2}, {3}]
==

[name=subquery_nested_recursive_union]
select 1 as key
|> recursive union all (
  from outer_alias
  |> recursive union all (
    from inner_alias
    |> set key = key + 1
    |> where key < 3
  ) as inner_alias
  |> set key = key + 1
  |> where key < 4
) as outer_alias
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {3}, {2}, {3}]
==

[name=subpipeline_nested_recursive_union]
select 1 as key
|> recursive union all (
  |> recursive union all (
    |> set key = key + 1
    |> where key < 3
  )
  |> set key = key + 1
  |> where key < 4
) as outer_alias
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {3}, {2}, {3}]
==

[name=subquery_nested_recursive_union_with_same_alias]
select 1 as key
|> recursive union all (
  from t
  |> recursive union all (
    from t
    |> set key = key + 1
    |> where key < 3
  ) as t
  |> set key = key + 1
  |> where key < 4
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {3}, {2}, {3}]
==

[name=subpipeline_nested_recursive_union_with_same_alias]
select 1 as key
|> recursive union all (
  |> recursive union all (
    |> set key = key + 1
    |> where key < 3
  ) as t
  |> set key = key + 1
  |> where key < 4
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {3}, {2}, {3}]
==

[name=subquery_recursive_reference_is_not_the_initial_table]
select 1 as key
|> recursive union all (
  select 1 as key
  |> join t using (key)
  |> set key = key + 1
  |> where key < 3
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {2}]
==

[name=subquery_recursive_reference_with_join]
select 1 as key
|> recursive union all (
  from t
  |> inner join keyvalue on (t.key = keyvalue.key)
  |> select t.key
  |> set key = key + 1
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {2}, {3}, {4}]
==

[name=subpipeline_recursive_reference_with_join]
select 1 as key
|> recursive union all (
  |> inner join keyvalue on (t.key = keyvalue.key)
  |> select t.key
  |> set key = key + 1
) as t
--
ARRAY<STRUCT<key INT64>>[unknown order:{1}, {2}, {3}, {4}]
==

[name=subquery_tree_traversal_root_to_leaf]
# Finds the path from node 1 to its leaf nodes.
# Tree structure:
# 1
# |- 2
#   |- 3
# |- 4
#   |- 5
#   |- 6
select 1 as node_id, 0 as depth
|> recursive union all (
  from t
  |> join TreeNodes child_node on (child_node.parent_id = t.node_id)
  |> select child_node.node_id, depth + 1 as depth
) as t
--
ARRAY<STRUCT<node_id INT64, depth INT64>>[unknown order:
  {1, 0},
  {4, 1},
  {2, 1},
  {5, 2},
  {6, 2},
  {3, 2}
]
==

# Same as the above but with depth modifier.
[name=subquery_tree_traversal_root_to_leaf_with_depth_modifier]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
select 1 as node_id
|> recursive union all with depth(
  from t
  |> join TreeNodes child_node on (child_node.parent_id = t.node_id)
  |> select child_node.node_id
) as t
--
ARRAY<STRUCT<node_id INT64, depth INT64>>[unknown order:
  {1, 0},
  {4, 1},
  {2, 1},
  {6, 2},
  {3, 2},
  {5, 2}
]
==

[name=subpipeline_tree_traversal_root_to_leaf]
# Finds the path from node 1 to its leaf nodes.
# Tree structure:
# 1
# |- 2
#   |- 3
# |- 4
#   |- 5
#   |- 6
select 1 as node_id, 0 as depth
|> recursive union all (
  |> join TreeNodes child_node on (child_node.parent_id = t.node_id)
  |> select child_node.node_id, depth + 1 as depth
) as t
--
ARRAY<STRUCT<node_id INT64, depth INT64>>[unknown order:
  {1, 0},
  {4, 1},
  {2, 1},
  {5, 2},
  {6, 2},
  {3, 2}
]
==

# Same as the above but with depth modifier.
[name=subpipeline_tree_traversal_root_to_leaf_with_depth_modifier]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
select 1 as node_id
|> recursive union all with depth (
  |> join TreeNodes child_node on (child_node.parent_id = t.node_id)
  |> select child_node.node_id
) as t
--
ARRAY<STRUCT<node_id INT64, depth INT64>>[unknown order:
  {1, 0},
  {4, 1},
  {2, 1},
  {6, 2},
  {3, 2},
  {5, 2}
]
==

[name=subquery_tree_traversal_leaf_to_root]
# Finds the path from node 6 to its root.
# Tree structure:
# 1
# |- 2
#   |- 3
# |- 4
#   |- 5
#   |- 6
select 6 as node_id, 0 as distance
|> recursive union all (
  from t
  |> join TreeNodes using (node_id)
  |> where parent_id is not null
  |> select parent_id, distance + 1 as distance
) as t
--
ARRAY<STRUCT<node_id INT64, distance INT64>>[unknown order:
  {6, 0},
  {4, 1},
  {1, 2}
]
==

[name=subpipeline_tree_traversal_leaf_to_root]
# Finds the path from node 6 to its root.
# Tree structure:
# 1
# |- 2
#   |- 3
# |- 4
#   |- 5
#   |- 6
select 6 as node_id, 0 as distance
|> recursive union all (
  |> join TreeNodes using (node_id)
  |> where parent_id is not null
  |> select parent_id, distance + 1 as distance
)
--
ARRAY<STRUCT<node_id INT64, distance INT64>>[unknown order:
  {6, 0},
  {4, 1},
  {1, 2}
]
==

# This does not have a corresponding with recursive query because the
# non-recursive term is correlated.
[name=subquery_input_scan_has_correlated_columns]
from keyvalue
|> select (
  select key
  |> recursive union all (
    from t
    |> set key = key + 1
    |> where key < 3
  ) as t
  |> aggregate count(*)
)
--
ARRAY<STRUCT<INT64>>[unknown order:{1}, {2}, {1}]
==

[name=subpipeline_input_scan_has_correlated_columns]
from keyvalue
|> select (
  select key
  |> recursive union all (
    |> set key = key + 1
    |> where key < 3
  )
  |> aggregate count(*)
)
--
ARRAY<STRUCT<INT64>>[unknown order:{1}, {2}, {1}]
==

[name=subquery_input_scan_has_correlated_columns_union_distinct]
from keyvalue
|> select (
  select key
  |> recursive union distinct (
    from t
  ) as t
  |> aggregate count(*)
)
--
ARRAY<STRUCT<INT64>>[unknown order:{1}, {1}, {1}]
==

[name=subpipeline_input_scan_has_correlated_columns_union_distinct]
from keyvalue
|> select (
  select key
  |> recursive union distinct () as t
  |> aggregate count(*)
)
--
ARRAY<STRUCT<INT64>>[unknown order:{1}, {1}, {1}]
==

# Value table as the input.
[name=subquery_value_table_as_input]
select as value struct(1 as key, "value1" as value)
|> recursive union all  (
  from t
  |> select key
  |> set key = key + 1
  |> where key < 3
  |> select struct(key, "dummy")
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "dummy"}
]
==

[name=subpipeline_value_table_as_input]
select as value struct(1 as key, "value1" as value)
|> recursive union all  (
  |> select key
  |> set key = key + 1
  |> where key < 3
  |> select struct(key, "dummy")
) as t
--
ARRAY<STRUCT<key INT64, value STRING>>[unknown order:
  {1, "value1"},
  {2, "dummy"}
]
==

# Value table as input but the intial scan of the recursive term is not the
# recursive table.
[name=subquery_value_table_as_input_initial_scan_not_recursive_table]
select as value 1 as key
|> recursive union distinct (
  from keyvalue
  |> select key
  |> union all (from t)
) as t
--
ARRAY<INT64>[unknown order:1, 2, 3]
==

# Value table inside the recursive term.
[name=subquery_value_table_as_input_in_recursive_term]
select 1 as col
|> recursive union distinct (
  from t
  |> select as value 2
) as t
--
ARRAY<STRUCT<col INT64>>[unknown order:{1}, {2}]
==

[name=subpipeline_value_table_as_input_in_recursive_term]
select 1 as col
|> recursive union distinct (
  |> select as value 2
)
--
ARRAY<STRUCT<col INT64>>[unknown order:{1}, {2}]
==

# Mixed subpipeline and subquery inputs.
[name=subquery_mixed_subpipeline_and_subquery_inputs]
select 1 as key
|> recursive union all (
  from keyvalue
  |> inner join t using (key)
  |> select key + 1 as key
  |> where key < 3
) as t
|> recursive union all (
  |> select key + 2 as key
  |> where key < 4
)
--
ARRAY<STRUCT<key INT64>>[unknown order:{2}, {1}, {3}]
==

[name=subquery_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
select 1 as key
|> recursive union all with depth between 1 and 3 (
  from t
  |> select key + 1 as key
) as t
|> order by depth
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:{2, 1}, {3, 2}, {4, 3}]
==

[name=aliased_subpipeline_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
select 1 as key
|> recursive union all with depth between 1 and 3 (
  |> select key + 1 as key
) as t
|> order by t.depth
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:{2, 1}, {3, 2}, {4, 3}]
==

[name=unaliased_subpipeline_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
select 1 as key
|> recursive union all with depth between 1 and 3 (
  |> select key + 1 as key
)
|> order by depth
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:{2, 1}, {3, 2}, {4, 3}]
==

[name=union_all_subquery_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union all with depth max 2 (
  from t
  |> select key + 1 as key
) as t
|> order by depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:
  {1, 0},
  {2, 0},
  {2, 1},
  {3, 1},
  {3, 2},
  {4, 2}
]
==

[name=union_distinct_subquery_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union distinct with depth max 2 (
  from t
  |> select key + 1 as key
) as t
|> order by depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:
  {1, 0},
  {2, 0},
  {3, 1},
  {4, 2}
]
==

[name=union_all_aliased_subpipeline_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union all with depth max 2 (
  |> select key + 1 as key
) as t
|> order by t.depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:
  {1, 0},
  {2, 0},
  {2, 1},
  {3, 1},
  {3, 2},
  {4, 2}
]
==

[name=union_distinct_aliased_subpipeline_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union distinct with depth max 2 (
  |> select key + 1 as key
) as t
|> order by t.depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:
  {1, 0},
  {2, 0},
  {3, 1},
  {4, 2}
]
==

[name=union_all_unaliased_subpipeline_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union all with depth max 2 (
  |> select key + 1 as key
)
|> order by depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:
  {1, 0},
  {2, 0},
  {2, 1},
  {3, 1},
  {3, 2},
  {4, 2}
]
==

[name=union_distinct_unaliased_subpipeline_with_depth]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union distinct with depth max 2 (
  |> select key + 1 as key
)
|> order by depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:
  {1, 0},
  {2, 0},
  {3, 1},
  {4, 2}
]
==

[name=union_distinct_subquery_with_depth_between]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union distinct with depth between 1 and 3 (
  from t
  |> select key + 1 as key
) as t
|> order by depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:{3, 1}, {4, 2}, {5, 3}]
==

[name=union_distinct_aliased_subpipeline_with_depth_between]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union distinct with depth between 1 and 3 (
  |> select key + 1 as key
) as t
|> order by t.depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:{3, 1}, {4, 2}, {5, 3}]
==

[name=union_distinct_unaliased_subpipeline_with_depth_between]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER]
(select 1 as key union all select 2)
|> recursive union distinct with depth between 1 and 3 (
  |> select key + 1 as key
)
|> order by depth, key
--
ARRAY<STRUCT<key INT64, depth INT64>>[known order:{3, 1}, {4, 2}, {5, 3}]
==

[name=by_name_with_depth_subquery]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER,CORRESPONDING_FULL,BY_NAME]
select 1 as a, 2 as b
|> recursive union all by name with depth between 1 and 3 (
  from t
  |> select b + 1 as b, a + 1 as a
) as t
|> order by depth, a, b
--
ARRAY<STRUCT<a INT64, b INT64, depth INT64>>[known order:
  {2, 3, 1},
  {3, 4, 2},
  {4, 5, 3}
]
==

[name=by_name_with_depth_subpipeline_with_alias]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER,CORRESPONDING_FULL,BY_NAME]
select 1 as a, 2 as b
|> recursive union all by name with depth between 1 and 3 (
  |> select b + 1 as b, a + 1 as a
) as t
|> order by depth, a, b
--
ARRAY<STRUCT<a INT64, b INT64, depth INT64>>[known order:
  {2, 3, 1},
  {3, 4, 2},
  {4, 5, 3}
]
==

[name=by_name_with_depth_subpipeline_no_alias]
[required_features=PIPES,PIPE_RECURSIVE_UNION,WITH_RECURSIVE_DEPTH_MODIFIER,CORRESPONDING_FULL,BY_NAME]
select 1 as a, 2 as b
|> recursive union all by name with depth between 1 and 3 (
  |> select b + 1 as b, a + 1 as a
)
|> order by depth, a, b
--
ARRAY<STRUCT<a INT64, b INT64, depth INT64>>[known order:
  {2, 3, 1},
  {3, 4, 2},
  {4, 5, 3}
]
==

[name=by_name_subquery_union_distinct]
[required_features=PIPES,PIPE_RECURSIVE_UNION,CORRESPONDING_FULL,BY_NAME]
select 1 as a, 2 as b
|> recursive union distinct by name (
  from t
  |> select 2 as b, 1 as a
) as t
--
ARRAY<STRUCT<a INT64, b INT64>>[{1, 2}]
==

[name=by_name_subpipeline_with_alias_union_distinct]
[required_features=PIPES,PIPE_RECURSIVE_UNION,CORRESPONDING_FULL,BY_NAME]
select 1 as a, 2 as b
|> recursive union distinct by name (
  |> select 2 as b, 1 as a
) as t
--
ARRAY<STRUCT<a INT64, b INT64>>[{1, 2}]
==

[name=by_name_subpipeline_no_alias_union_distinct]
[required_features=PIPES,PIPE_RECURSIVE_UNION,CORRESPONDING_FULL,BY_NAME]
select 1 as a, 2 as b
|> recursive union distinct by name (
  |> select 2 as b, 1 as a
)
--
ARRAY<STRUCT<a INT64, b INT64>>[{1, 2}]
==

[name=strict_corresponding_subquery_union_distinct]
[required_features=PIPES,PIPE_RECURSIVE_UNION,CORRESPONDING_FULL]
select 1 as a, 2 as b
|> recursive union distinct strict corresponding (
  from t
  |> select 2 as b, 1 as a
) as t
--
ARRAY<STRUCT<a INT64, b INT64>>[{1, 2}]
==

[name=strict_corresponding_subpipeline_with_alias_union_distinct]
[required_features=PIPES,PIPE_RECURSIVE_UNION,CORRESPONDING_FULL]
select 1 as a, 2 as b
|> recursive union distinct strict corresponding (
  |> select 2 as b, 1 as a
) as t
--
ARRAY<STRUCT<a INT64, b INT64>>[{1, 2}]
==

[name=strict_corresponding_subpipeline_no_alias_union_distinct]
[required_features=PIPES,PIPE_RECURSIVE_UNION,CORRESPONDING_FULL]
select 1 as a, 2 as b
|> recursive union distinct strict corresponding (
  |> select 2 as b, 1 as a
)
--
ARRAY<STRUCT<a INT64, b INT64>>[{1, 2}]
==

[name=where_clause_in_recursive_term]
SELECT 1 AS a, 1 AS b, 1 AS step
|> RECURSIVE UNION ALL (
     |> SELECT b, a+b, step+1 as next_step
     |> WHERE next_step < 10
   )
|> SELECT step, a
|> ORDER BY step;
--
ARRAY<STRUCT<step INT64, a INT64>>[known order:
  {1, 1},
  {2, 1},
  {3, 2},
  {4, 3},
  {5, 5},
  {6, 8},
  {7, 13},
  {8, 21},
  {9, 34}
]

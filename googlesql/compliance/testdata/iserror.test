[prepare_database]
CREATE TABLE T AS
SELECT 0 AS A,  0 AS B,  0.0 AS C UNION ALL
SELECT 1,      10,      100.0     UNION ALL
SELECT 2,      20,      200.0
--
ARRAY<STRUCT<A INT64, B INT64, C DOUBLE>>[
  {0, 0, 0},
  {1, 10, 100},
  {2, 20, 200}
]
==
[prepare_database]
CREATE TABLE TestTable AS
SELECT 1 AS id, TRUE AS bool_val, 'a' AS str_val
  UNION ALL
  SELECT 2, NULL, 'b'
  UNION ALL
  SELECT 3, NULL, 'c'
  UNION ALL
  SELECT 4, NULL, NULL
--
ARRAY<STRUCT<id INT64, bool_val BOOL, str_val STRING>>[
  {1, true, "a"},
  {2, NULL, "b"},
  {3, NULL, "c"},
  {4, NULL, NULL}
]
==
[name=no_error]
SELECT ISERROR(1);
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=try_expr_has_constant_folding_error]
SELECT ISERROR(CAST('a' AS DATE));
--
ARRAY<STRUCT<BOOL>>[{true}]
==
# Note that the inner error is absorbed, so the outer returns false
[name=nested_try_expr_has_constant_folding_error]
SELECT ISERROR(ISERROR(CAST('inner' AS DATE)));
--
ARRAY<STRUCT<BOOL>>[{false}]
==
[name=nested_try_expr_has_constant_folding_error_conditioned_on_aggregation]
SELECT ISERROR(ISERROR(IF(SUM(C) > 0, NULL, CAST('inner' AS DATE)))) FROM T GROUP BY A;
--
ARRAY<STRUCT<BOOL>>[unknown order:{false}, {false}, {false}]
==
[name=expr_has_error_should_still_be_foldable]
SELECT ISERROR(1/0);
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=expr_has_error_non_foldable]
SELECT ISERROR(A/0) FROM T;
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]
==
[name=nested_iserror_absorbs_errors]
SELECT ISERROR(IF(ISERROR(A/0), NULL, NULL)) FROM T;
--
ARRAY<STRUCT<BOOL>>[unknown order:{false}, {false}, {false}]
==
[name=aggregate_expr_error_explicit_grouping]
SELECT ISERROR((SELECT SUM(A/0) FROM T)) FROM T GROUP BY B;
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]
==
[name=lambda_with_error_in_arg]
[required_features=INLINE_LAMBDA_ARGUMENT]
SELECT ISERROR(ARRAY_FILTER([B, B/0], e -> e > 1)[OFFSET(0)]) FROM T GROUP BY B
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]
==
[name=lambda_with_error_in_body]
[required_features=INLINE_LAMBDA_ARGUMENT]
SELECT ISERROR(ARRAY_FILTER([A, A*2], e -> 1/e > 1)[OFFSET(0)]) FROM T GROUP BY A
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]
==
[name=reference_to_subquery_with_error_not_absorbed]
SELECT ISERROR(Y) FROM (SELECT 1/0 AS Y)
--
ERROR: generic::out_of_range: division by zero: 1 / 0
==
[name=arithmetic_reference_to_subquery_with_error_not_absorbed]
SELECT ISERROR(Y+Y) FROM (SELECT 1/0 AS Y)
--
ERROR: generic::out_of_range: division by zero: 1 / 0
==
[name=aggregate_expr_error_implicit_grouping]
[required_features=ENFORCE_CONDITIONAL_EVALUATION]
SELECT ISERROR(SUM(A/0)) FROM T
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=iserror_on_uninlined_aggregated_subquery_with_error]
SELECT ISERROR(A) FROM (SELECT MAX(A/0) AS A FROM T)
--
ERROR: generic::out_of_range: division by zero: 1 / 0
==
[name=iferror_on_inlined_scalar_subquery_with_error_grouped]
SELECT ISERROR((SELECT 1/0 AS X)) FROM T GROUP BY B
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]
==
[name=iserror_on_inlined_scalar_subquery_with_error]
SELECT ISERROR((SELECT 1/0 AS A))
--
ARRAY<STRUCT<BOOL>>[{true}]
==
[name=iserror_as_group_by_expression]
SELECT COUNT(B) FROM T GROUP BY ISERROR(1/A)
--
ARRAY<STRUCT<INT64>>[unknown order:{2}, {1}]
==
[name=iserror_as_having_expression]
SELECT MAX(B) FROM T GROUP BY A HAVING ISERROR(A + 1/A)
--
ARRAY<STRUCT<INT64>>[{0}]
==
[name=iserror_as_order_by_expression]
SELECT C FROM T ORDER BY ISERROR(1/A)
--
ARRAY<STRUCT<C DOUBLE>>[unknown order:{100}, {200}, {0}]
==
# This is a non-computation error: the subquery returns mutliple rows instead
# of one.
[name=iserror_in_where_clause_handles_scalar_subquery_returning_multiple_rows]
SELECT C FROM T WHERE ISERROR(B = (SELECT 10*A FROM T))
--
ARRAY<STRUCT<C DOUBLE>>[unknown order:{100}, {0}, {200}]
==
[name=iserror_is_not_affected_by_neighboring_safe_calls]
SELECT AVG(safe_divide(1, 0)), MAX(ISERROR(A)) FROM T
--
ARRAY<STRUCT<DOUBLE, BOOL>>[{NULL, false}]
==
[name=safe_mode]
[required_features=SAFE_FUNCTION_CALL]
SELECT SAFE.ISERROR(A/0) FROM T;
--
ARRAY<STRUCT<BOOL>>[unknown order:{true}, {true}, {true}]
==
[name=safe_mode_no_error]
[required_features=SAFE_FUNCTION_CALL]
SELECT SAFE.ISERROR(A) FROM T;
--
ARRAY<STRUCT<BOOL>>[unknown order:{false}, {false}, {false}]

[default reserve_graph_table]
[load_proto_files=googlesql/testdata/test_schema.proto]
[load_proto_names=googlesql_test.KitchenSinkPB]

[prepare_database]
CREATE TABLE person AS
(SELECT 1 AS id, "name1" AS name) UNION ALL
(SELECT 2 AS id, "name2" AS name) UNION ALL
(SELECT 3 as id, "name3" AS name) UNION ALL
(SELECT 4 as id, "name4" AS name)
--
ARRAY<STRUCT<id INT64, name STRING>>[
  {1, "name1"},
  {2, "name2"},
  {3, "name3"},
  {4, "name4"}
]
==

[prepare_database]
CREATE TABLE person_knows_person AS
(SELECT 100 AS id, 2 AS from_person_id, 1 AS to_person_id, 1 AS distance, TIMESTAMP '2000-01-01 00:00:00' AS since) UNION ALL
(SELECT 200 AS id, 1 AS from_person_id, 2 AS to_person_id, 1 AS distance, TIMESTAMP '2000-01-02 00:00:00' AS since) UNION ALL
(SELECT 300 AS id, 2 AS from_person_id, 3 AS to_person_id, 5 AS distance, TIMESTAMP '2000-01-03 00:00:00' AS since) UNION ALL
(SELECT 400 AS id, 3 AS from_person_id, 1 AS to_person_id, 10 AS distance, TIMESTAMP '2000-01-04 00:00:00' AS since) UNION ALL
(SELECT 500 AS id, 3 AS from_person_id, 4 AS to_person_id, 100 AS distance, TIMESTAMP '2000-01-05 00:00:00' AS since)
--
ARRAY<STRUCT<id INT64,
             from_person_id INT64,
             to_person_id INT64,
             distance INT64,
             since TIMESTAMP>>
[{
   100,
   2,
   1,
   1,
   2000-01-01 08:00:00+00
 },
 {
   200,
   1,
   2,
   1,
   2000-01-02 08:00:00+00
 },
 {
   300,
   2,
   3,
   5,
   2000-01-03 08:00:00+00
 },
 {
   400,
   3,
   1,
   10,
   2000-01-04 08:00:00+00
 },
 {
   500,
   3,
   4,
   100,
   2000-01-05 08:00:00+00
 }]
==

[prepare_database]
CREATE PROPERTY GRAPH aml_cyclic
  NODE TABLES (
    Person KEY(id)
    LABEL Human PROPERTIES(
      id,
      name)
    LABEL HasId PROPERTIES (id as key_id))
  EDGE TABLES (
    person_knows_person AS Knows KEY(id)
              SOURCE KEY(from_person_id) REFERENCES Person(id)
              DESTINATION KEY(to_person_id) REFERENCES Person(id)
              DEFAULT LABEL PROPERTIES(id, distance, since),

  )
==

[name=walk_mode_quantified_two_hop_and_one_hop_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH ((a)->{2}())->(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[unknown order:
  {1, 1},
  {1, 2},
  {1, 4},
  {2, 1},
  {2, 2},
  {2, 3},
  {3, 1},
  {3, 3}
]
==

[name=walk_mode_quantified_three_hop_nodes_edges]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH ((a)-[e]->{3})(b)
return a.id AS src_id, b.id AS dest_id, e[OFFSET(0)].id AS eid1, e[OFFSET(1)].id AS eid2, e[OFFSET(2)].id AS eid3
ORDER BY src_id, dest_id, eid1, eid2, eid3
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, eid1 INT64, eid2 INT64, eid3 INT64>>[unknown order:
  {1, 1, 200, 300, 400},
  {1, 2, 200, 100, 200},
  {1, 4, 200, 300, 500},
  {2, 1, 100, 200, 100},
  {2, 2, 300, 400, 200},
  {2, 3, 100, 200, 300},
  {3, 1, 400, 200, 100},
  {3, 3, 400, 200, 300}
]
==

[name=walk_mode_quantified_three_hop_edges_count_paths]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH (-[e]->{3})()
RETURN COUNT(1) AS num_paths
--
ARRAY<STRUCT<num_paths INT64>>[{8}]
==

[name=trail_mode_quantified_two_hop_and_one_hop_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH TRAIL ((a)->{2}())->(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[unknown order:
  {1, 1},
  {1, 4},
  {2, 2},
  {2, 3},
  {3, 1},
  {3, 3}
]
==

[name=trail_mode_quantified_three_hop_nodes_edges]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH TRAIL ((a)-[e]->{3})(b)
return a.id AS src_id, b.id AS dest_id, e[OFFSET(0)].id AS eid1, e[OFFSET(1)].id AS eid2, e[OFFSET(2)].id AS eid3
ORDER BY src_id, dest_id, eid1, eid2, eid3
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, eid1 INT64, eid2 INT64, eid3 INT64>>[unknown order:
  {1, 1, 200, 300, 400},
  {1, 4, 200, 300, 500},
  {2, 2, 300, 400, 200},
  {2, 3, 100, 200, 300},
  {3, 1, 400, 200, 100},
  {3, 3, 400, 200, 300}
]
==

[name=trail_mode_quantified_three_hop_edges_count_paths]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH TRAIL (-[e]->{3})()
RETURN COUNT(1) AS num_paths
--
ARRAY<STRUCT<num_paths INT64>>[{6}]
==

[name=acyclic_mode_quantified_two_hop_and_one_hop_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH ACYCLIC ((a)->{2}())->(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[{1, 4}]
==

[name=acyclic_mode_quantified_three_hop_nodes_edges]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH ACYCLIC ((a)-[e]->{3})(b)
return a.id AS src_id, b.id AS dest_id, e[OFFSET(0)].id AS eid1, e[OFFSET(1)].id AS eid2, e[OFFSET(2)].id AS eid3
ORDER BY src_id, dest_id, eid1, eid2, eid3
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, eid1 INT64, eid2 INT64, eid3 INT64>>[
  {1, 4, 200, 300, 500}
]
==

[name=acyclic_mode_quantified_three_hop_edges_count_paths]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH ACYCLIC (-[e]->{3})()
RETURN COUNT(1) AS num_paths
--
ARRAY<STRUCT<num_paths INT64>>[{1}]
==

[name=simple_mode_quantified_two_hop_and_one_hop_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH SIMPLE ((a)->{2}())->(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[unknown order:
  {1, 1},
  {1, 4},
  {2, 2},
  {3, 3}
]
==

[name=simple_mode_quantified_three_hop_nodes_edges]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH SIMPLE ((a)-[e]->{3})(b)
return a.id AS src_id, b.id AS dest_id, e[OFFSET(0)].id AS eid1, e[OFFSET(1)].id AS eid2, e[OFFSET(2)].id AS eid3
ORDER BY src_id, dest_id, eid1, eid2, eid3
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, eid1 INT64, eid2 INT64, eid3 INT64>>[unknown order:
  {1, 1, 200, 300, 400},
  {1, 4, 200, 300, 500},
  {2, 2, 300, 400, 200},
  {3, 3, 400, 200, 300}
]
==

[name=simple_mode_quantified_three_hop_edges_count_paths]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE]
GRAPH aml_cyclic
MATCH SIMPLE (-[e]->{3})()
RETURN COUNT(1) AS num_paths
--
ARRAY<STRUCT<num_paths INT64>>[{4}]
==

[name=trail_mode_three_to_unbounded_hops_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH TRAIL (a)->{3,}(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[unknown order:
  {1, 1},
  {1, 4},
  {2, 1},
  {2, 1},
  {2, 2},
  {2, 3},
  {2, 4},
  {3, 1},
  {3, 3},
  {3, 4}
]
==

[name=acyclic_mode_two_to_unbounded_hops_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH ACYCLIC (a)->{2,}(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[unknown order:
  {1, 3},
  {1, 4},
  {2, 1},
  {2, 4},
  {3, 2}
]
==

[name=acyclic_mode_three_to_unbounded_hops_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH ACYCLIC (a)->{3,}(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[{1, 4}]
==

[name=simple_mode_three_to_unbounded_hops_nodes]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_MODE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH SIMPLE (a)->{3,}(b)
return a.id AS src_id, b.id AS dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64>>[unknown order:
  {1, 1},
  {1, 4},
  {2, 2},
  {3, 3}
]
==

[name=any_quantified_one_to_ten_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH ANY (a)->{1, 10}(b)
RETURN a.id AS src_id, b.id AS dest_id, COUNT(*) AS num_paths
GROUP BY src_id, dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, num_paths INT64>>[unknown order:
  {1, 1, 1},
  {1, 2, 1},
  {1, 3, 1},
  {1, 4, 1},
  {2, 1, 1},
  {2, 2, 1},
  {2, 3, 1},
  {2, 4, 1},
  {3, 1, 1},
  {3, 2, 1},
  {3, 3, 1},
  {3, 4, 1}
]
==

[name=any_k_quantified_one_to_ten_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_SEARCH_PREFIX_PATH_COUNT]
GRAPH aml_cyclic
MATCH ANY 2 (a)->{1, 10}(b)
RETURN a.id AS src_id, b.id AS dest_id, COUNT(*) AS num_paths
GROUP BY src_id, dest_id
ORDER BY src_id, dest_id
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, num_paths INT64>>[unknown order:
  {1, 1, 2},
  {1, 2, 2},
  {1, 3, 2},
  {1, 4, 2},
  {2, 1, 2},
  {2, 2, 2},
  {2, 3, 2},
  {2, 4, 2},
  {3, 1, 2},
  {3, 2, 2},
  {3, 3, 2},
  {3, 4, 2}
]
==

[name=any_path_var_one_to_unbounded_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH p = ANY (a)->{1,}(b)
return a.id AS src_id, b.id AS dest_id, path_length(p) AS len
ORDER BY src_id, dest_id, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, len INT64>>[unknown order:
  {1, 1, 2},
  {1, 2, 1},
  {1, 3, 2},
  {1, 4, 3},
  {2, 1, 1},
  {2, 2, 2},
  {2, 3, 1},
  {2, 4, 2},
  {3, 1, 1},
  {3, 2, 2},
  {3, 3, 3},
  {3, 4, 1}
]
==


[name=any_k_path_var_one_to_unbounded_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_PATH_SEARCH_PREFIX_PATH_COUNT,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH p = ANY 2 (a)->{1,}(b)
return a.id AS src_id, b.id AS dest_id, path_length(p) AS len
ORDER BY src_id, dest_id, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, len INT64>>[unknown order:
  {1, 1, 2},
  {1, 1, 3},
  {1, 2, 1},
  {1, 2, 3},
  {1, 3, 2},
  {1, 3, 4},
  {1, 4, 3},
  {1, 4, 5},
  {2, 1, 1},
  {2, 1, 2},
  {2, 2, 2},
  {2, 2, 3},
  {2, 3, 1},
  {2, 3, 3},
  {2, 4, 2},
  {2, 4, 4},
  {3, 1, 1},
  {3, 1, 3},
  {3, 2, 2},
  {3, 2, 4},
  {3, 3, 3},
  {3, 3, 5},
  {3, 4, 1},
  {3, 4, 4}
]
==

[name=shortest_path_var_quantified_one_to_ten_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE]
GRAPH aml_cyclic
MATCH p = ANY SHORTEST (a)->{1, 10}(b)
return a.id AS src_id, b.id AS dest_id, path_length(p) AS len
ORDER BY src_id, dest_id, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, len INT64>>[unknown order:
  {1, 1, 2},
  {1, 2, 1},
  {1, 3, 2},
  {1, 4, 3},
  {2, 1, 1},
  {2, 2, 2},
  {2, 3, 1},
  {2, 4, 2},
  {3, 1, 1},
  {3, 2, 2},
  {3, 3, 3},
  {3, 4, 1}
]
==

[name=shortest_k_path_var_quantified_one_to_ten_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_PATH_SEARCH_PREFIX_PATH_COUNT]
GRAPH aml_cyclic
MATCH p = SHORTEST 2 (a)->{1, 10}(b)
return a.id AS src_id, b.id AS dest_id, path_length(p) AS len
ORDER BY src_id, dest_id, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, len INT64>>[unknown order:
  {1, 1, 2},
  {1, 1, 3},
  {1, 2, 1},
  {1, 2, 3},
  {1, 3, 2},
  {1, 3, 4},
  {1, 4, 3},
  {1, 4, 5},
  {2, 1, 1},
  {2, 1, 2},
  {2, 2, 2},
  {2, 2, 3},
  {2, 3, 1},
  {2, 3, 3},
  {2, 4, 2},
  {2, 4, 4},
  {3, 1, 1},
  {3, 1, 3},
  {3, 2, 2},
  {3, 2, 4},
  {3, 3, 3},
  {3, 3, 5},
  {3, 4, 1},
  {3, 4, 4}
]
==

[name=shortest_path_var_one_to_unbounded_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH p = ANY SHORTEST (a)->{1,}(b)
return a.id AS src_id, b.id AS dest_id, path_length(p) AS len
ORDER BY src_id, dest_id, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, len INT64>>[unknown order:
  {1, 1, 2},
  {1, 2, 1},
  {1, 3, 2},
  {1, 4, 3},
  {2, 1, 1},
  {2, 2, 2},
  {2, 3, 1},
  {2, 4, 2},
  {3, 1, 1},
  {3, 2, 2},
  {3, 3, 3},
  {3, 4, 1}
]
==

[name=shortest_k_path_var_one_to_unbounded_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_PATH_SEARCH_PREFIX_PATH_COUNT,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION]
GRAPH aml_cyclic
MATCH p = SHORTEST 2 (a)->{1,}(b)
return a.id AS src_id, b.id AS dest_id, path_length(p) AS len
ORDER BY src_id, dest_id, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, len INT64>>[unknown order:
  {1, 1, 2},
  {1, 1, 3},
  {1, 2, 1},
  {1, 2, 3},
  {1, 3, 2},
  {1, 3, 4},
  {1, 4, 3},
  {1, 4, 5},
  {2, 1, 1},
  {2, 1, 2},
  {2, 2, 2},
  {2, 2, 3},
  {2, 3, 1},
  {2, 3, 3},
  {2, 4, 2},
  {2, 4, 4},
  {3, 1, 1},
  {3, 1, 3},
  {3, 2, 2},
  {3, 2, 4},
  {3, 3, 3},
  {3, 3, 5},
  {3, 4, 1},
  {3, 4, 4}
]
==

[name=cheapest_path_var_quantified_one_to_ten_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_CHEAPEST_PATH,V_1_3_UNNEST_AND_FLATTEN_ARRAYS,ARRAY_AGGREGATION_FUNCTIONS]
GRAPH aml_cyclic
MATCH p = ANY CHEAPEST (a)-[e COST e.distance]->{1, 10}(b)
LET distances = flatten(e.distance)
return a.id AS src_id, b.id AS dest_id, array_sum(distances) AS total_cost, path_length(p) AS len
ORDER BY src_id, dest_id, total_cost, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, total_cost INT64, len INT64>>[unknown order:
  {1, 1, 2, 2},
  {1, 2, 1, 1},
  {1, 3, 6, 2},
  {1, 4, 106, 3},
  {2, 1, 1, 1},
  {2, 2, 2, 2},
  {2, 3, 5, 1},
  {2, 4, 105, 2},
  {3, 1, 10, 1},
  {3, 2, 11, 2},
  {3, 3, 16, 3},
  {3, 4, 100, 1}
]
==

[name=cheapest_k_path_var_quantified_one_to_ten_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_PATH_SEARCH_PREFIX_PATH_COUNT,SQL_GRAPH_CHEAPEST_PATH,V_1_3_UNNEST_AND_FLATTEN_ARRAYS,ARRAY_AGGREGATION_FUNCTIONS]
GRAPH aml_cyclic
MATCH p = CHEAPEST 2 (a)-[e COST e.distance]->{1, 10}(b)
LET distances = flatten(e.distance)
return a.id AS src_id, b.id AS dest_id, array_sum(distances) AS total_cost, path_length(p) AS len
ORDER BY src_id, dest_id, total_cost, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, total_cost INT64, len INT64>>[unknown order:
  {1, 1, 2, 2},
  {1, 1, 4, 4},
  {1, 2, 1, 1},
  {1, 2, 3, 3},
  {1, 3, 6, 2},
  {1, 3, 8, 4},
  {1, 4, 106, 3},
  {1, 4, 108, 5},
  {2, 1, 1, 1},
  {2, 1, 3, 3},
  {2, 2, 2, 2},
  {2, 2, 4, 4},
  {2, 3, 5, 1},
  {2, 3, 7, 3},
  {2, 4, 105, 2},
  {2, 4, 107, 4},
  {3, 1, 10, 1},
  {3, 1, 12, 3},
  {3, 2, 11, 2},
  {3, 2, 13, 4},
  {3, 3, 16, 3},
  {3, 3, 18, 5},
  {3, 4, 100, 1},
  {3, 4, 116, 4}
]
==

[name=cheapest_path_var_one_to_unbounded_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_CHEAPEST_PATH,V_1_3_UNNEST_AND_FLATTEN_ARRAYS,ARRAY_AGGREGATION_FUNCTIONS]
GRAPH aml_cyclic
MATCH p = ANY CHEAPEST (a)-[e COST e.distance]->{1,}(b)
LET distances = flatten(e.distance)
return a.id AS src_id, b.id AS dest_id, array_sum(distances) AS total_cost, path_length(p) AS len
ORDER BY src_id, dest_id, total_cost, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, total_cost INT64, len INT64>>[unknown order:
  {1, 1, 2, 2},
  {1, 2, 1, 1},
  {1, 3, 6, 2},
  {1, 4, 106, 3},
  {2, 1, 1, 1},
  {2, 2, 2, 2},
  {2, 3, 5, 1},
  {2, 4, 105, 2},
  {3, 1, 10, 1},
  {3, 2, 11, 2},
  {3, 3, 16, 3},
  {3, 4, 100, 1}
]
==

[name=cheapest_k_path_var_one_to_unbounded_hops]
[required_features=SQL_GRAPH,SQL_GRAPH_ADVANCED_QUERY,SQL_GRAPH_BOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_PATH_TYPE,SQL_GRAPH_PATH_SEARCH_PREFIX_PATH_COUNT,SQL_GRAPH_UNBOUNDED_PATH_QUANTIFICATION,SQL_GRAPH_CHEAPEST_PATH,V_1_3_UNNEST_AND_FLATTEN_ARRAYS,ARRAY_AGGREGATION_FUNCTIONS]
GRAPH aml_cyclic
MATCH p = CHEAPEST 2 (a)-[e COST e.distance]->{1,}(b)
LET distances = flatten(e.distance)
return a.id AS src_id, b.id AS dest_id, array_sum(distances) AS total_cost, path_length(p) AS len
ORDER BY src_id, dest_id, total_cost, len
--
ARRAY<STRUCT<src_id INT64, dest_id INT64, total_cost INT64, len INT64>>[unknown order:
  {1, 1, 2, 2},
  {1, 1, 4, 4},
  {1, 2, 1, 1},
  {1, 2, 3, 3},
  {1, 3, 6, 2},
  {1, 3, 8, 4},
  {1, 4, 106, 3},
  {1, 4, 108, 5},
  {2, 1, 1, 1},
  {2, 1, 3, 3},
  {2, 2, 2, 2},
  {2, 2, 4, 4},
  {2, 3, 5, 1},
  {2, 3, 7, 3},
  {2, 4, 105, 2},
  {2, 4, 107, 4},
  {3, 1, 10, 1},
  {3, 1, 12, 3},
  {3, 2, 11, 2},
  {3, 2, 13, 4},
  {3, 3, 16, 3},
  {3, 3, 18, 5},
  {3, 4, 100, 1},
  {3, 4, 116, 4}
]
==


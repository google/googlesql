[default language_features=MAXIMUM,+MATCH_RECOGNIZE]

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# In many of these basic cases, we're intentionally using:
# 1. SELECT *, to verify the output columns from MATCH_RECOGNIZE
# 2. Complex expressions over aggregates in the MEASURES clause to ensure they
#    are handled correctly (by an extra project scan)
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    ,-MATCH_RECOGNIZE,key DESC
    ,-MATCH_RECOGNIZE,key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 5:24]
select * from KeyValue MATCH_RECOGNIZE(
                       ^
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#8 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#8]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#8]
        +-expr_list=
        | +-m#8 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#7)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#6, $agg2#7]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |     +-$agg2#7 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#9 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#9]
        +-expr_list=
        | +-m#9 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#7, $agg2#8]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |           +-is_descending=TRUE
            |           +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |     +-$agg2#8 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
==

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# subquery
select * from (SELECT * FROM KeyValue) AS k MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    ,-MATCH_RECOGNIZE,key DESC
    ,-MATCH_RECOGNIZE,key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 2:45]
select * from (SELECT * FROM KeyValue) AS k MATCH_RECOGNIZE(
                                            ^
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#8 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#8]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#8]
        +-expr_list=
        | +-m#8 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#7)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#6, $agg2#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=KeyValue.[Key#1, Value#2]
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |     +-$agg2#7 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#9 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#9]
        +-expr_list=
        | +-m#9 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#7, $agg2#8]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-ProjectScan
            |       +-column_list=KeyValue.[Key#1, Value#2]
            |       +-input_scan=
            |         +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |           +-is_descending=TRUE
            |           +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |     +-$agg2#8 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
==

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# UNNEST
select * from UNNEST(['abc', 'def']) AS value MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: MATCH_RECOGNIZE is not allowed with array scans [at 2:47]
select * from UNNEST(['abc', 'def']) AS value MATCH_RECOGNIZE(
                                              ^
==

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# 2 UNNESTs
select * from UNNEST([1, 2]) AS key, UNNEST(['abc', 'def']) AS value
MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: MATCH_RECOGNIZE is not allowed with array scans [at 3:1]
MATCH_RECOGNIZE(
^
==

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# Table with 2 UNNESTs
select * from UNNEST([1, 2]) AS key, UNNEST(['abc', 'def']) AS value
MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: MATCH_RECOGNIZE is not allowed with array scans [at 3:1]
MATCH_RECOGNIZE(
^
==

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# TVF
select * from tvf_no_args()
MATCH_RECOGNIZE(
  ORDER BY column_bool
  MEASURES max(length(column_bytes)) AS m
  PATTERN (a b)
  DEFINE
    A AS column_bool,
    B AS NOT column_bool
)
--
ALTERNATION GROUP: ,-MATCH_RECOGNIZE
--
ERROR: MATCH_RECOGNIZE is not supported [at 3:1]
MATCH_RECOGNIZE(
^
--
ALTERNATION GROUP: <empty>
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TVFScan(column_list=tvf_no_args.[column_bool#1, column_bytes#2], tvf=tvf_no_args(() -> TABLE<column_bool BOOL, column_bytes BYTES>), signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>, column_index_list=[0, 1], function_call_signature=() -> TABLE<column_bool BOOL, column_bytes BYTES>)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=BOOL, column=tvf_no_args.column_bool#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-ColumnRef(type=BOOL, column=tvf_no_args.column_bool#1)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$not(BOOL) -> BOOL)
            |       +-ColumnRef(type=BOOL, column=tvf_no_args.column_bool#1)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(BYTES) -> INT64)
            |           +-ColumnRef(type=BYTES, column=tvf_no_args.column_bytes#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

[language_features=MAXIMUM{{,-MATCH_RECOGNIZE|}}]
# parenthesized join
select * from (KeyValue t1 INNER JOIN KeyValue t2 ON t1.key = t2.key)
MATCH_RECOGNIZE(
  ORDER BY {{t1.key DESC|t1.key + 1 DESC NULLS FIRST}}
  MEASURES max(length(t2.value)) - min(length(t2.value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(t1.value) < 10,
    B AS length(t2.value) >= 10
)
--

ALTERNATION GROUPS:
    ,-MATCH_RECOGNIZE,t1.key DESC
    ,-MATCH_RECOGNIZE,t1.key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 3:1]
MATCH_RECOGNIZE(
^
--
ALTERNATION GROUP: t1.key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#10 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#10]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#10]
        +-expr_list=
        | +-m#10 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#8)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#9)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#8, $agg2#9]
            +-input_scan=
            | +-JoinScan
            |   +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
            |   +-left_scan=
            |   | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
            |   +-right_scan=
            |   | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
            |   +-join_expr=
            |     +-FunctionCall(GoogleSQL:$equal(INT64, INT64) -> BOOL)
            |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#8 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            |     +-$agg2#9 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            +-match_number_column=$match_recognize.$match_number#5
            +-match_row_number_column=$match_recognize.$match_row_number#6
            +-classifier_column=$match_recognize.$classifier#7
--
ALTERNATION GROUP: t1.key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#11 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#11]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#11]
        +-expr_list=
        | +-m#11 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#9)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#10)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#9, $agg2#10]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, KeyValue.Key#3, KeyValue.Value#4, $orderby.$orderbycol1#5]
            |   +-expr_list=
            |   | +-$orderbycol1#5 :=
            |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-JoinScan
            |       +-column_list=KeyValue.[Key#1, Value#2, Key#3, Value#4]
            |       +-left_scan=
            |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t1")
            |       +-right_scan=
            |       | +-TableScan(column_list=KeyValue.[Key#3, Value#4], table=KeyValue, column_index_list=[0, 1], alias="t2")
            |       +-join_expr=
            |         +-FunctionCall(GoogleSQL:$equal(INT64, INT64) -> BOOL)
            |           +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-ColumnRef(type=INT64, column=KeyValue.Key#3)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#5)
            |           +-is_descending=TRUE
            |           +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#9 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            |     +-$agg2#10 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#4)
            +-match_number_column=$match_recognize.$match_number#6
            +-match_row_number_column=$match_recognize.$match_row_number#7
            +-classifier_column=$match_recognize.$classifier#8
==

[language_features=MAXIMUM,+SQL_GRAPH,{{,-MATCH_RECOGNIZE|}}]
select * from graph_table(aml MATCH (n) COLUMNS(n.age AS key, n.name AS value))
MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    ,-MATCH_RECOGNIZE,key DESC
    ,-MATCH_RECOGNIZE,key + 1 DESC NULLS FIRST
--
ERROR: MATCH_RECOGNIZE is not supported [at 2:1]
MATCH_RECOGNIZE(
^
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#9 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#9]
        +-expr_list=
        | +-m#9 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#7, $agg2#8]
            +-input_scan=
            | +-GraphTableScan
            |   +-column_list=$graph_table.[key#2, value#3]
            |   +-property_graph=aml
            |   +-input_scan=
            |   | +-GraphScan
            |   |   +-column_list=[$element_table.n#1]
            |   |   +-input_scan_list=
            |   |     +-GraphPathScan
            |   |       +-column_list=[$element_table.n#1]
            |   |       +-input_scan_list=
            |   |       | +-GraphNodeScan
            |   |       |   +-column_list=[$element_table.n#1]
            |   |       |   +-label_expr=
            |   |       |   | +-GraphLabelNaryExpr
            |   |       |   |   +-op=OR
            |   |       |   |   +-operand_list=
            |   |       |   |     +-GraphWildCardLabel
            |   |       |   |     +-GraphLabelNaryExpr
            |   |       |   |       +-op=NOT
            |   |       |   |       +-operand_list=
            |   |       |   |         +-GraphWildCardLabel
            |   |       |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
            |   |       +-head=$element_table.n#1
            |   |       +-tail=$element_table.n#1
            |   +-shape_expr_list=
            |     +-key#2 :=
            |     | +-GraphGetElementProperty
            |     |   +-type=UINT32
            |     |   +-expr=
            |     |   | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |     |   +-property=age(UINT32)
            |     |   +-property_name=
            |     |     +-Literal(type=STRING, value="age", has_explicit_type=TRUE)
            |     +-value#3 :=
            |       +-GraphGetElementProperty
            |         +-type=STRING
            |         +-expr=
            |         | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |         +-property=name(STRING)
            |         +-property_name=
            |           +-Literal(type=STRING, value="name", has_explicit_type=TRUE)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=UINT32, column=$graph_table.key#2)
            |           +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=$graph_table.value#3)
            |     +-$agg2#8 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=$graph_table.value#3)
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#10 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#10]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#10]
        +-expr_list=
        | +-m#10 :=
        |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#8)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg2#9)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#8, $agg2#9]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[$graph_table.key#2, $graph_table.value#3, $orderby.$orderbycol1#4]
            |   +-expr_list=
            |   | +-$orderbycol1#4 :=
            |   |   +-FunctionCall(GoogleSQL:$add(UINT64, UINT64) -> UINT64)
            |   |     +-Cast(UINT32 -> UINT64)
            |   |     | +-ColumnRef(type=UINT32, column=$graph_table.key#2)
            |   |     +-Literal(type=UINT64, value=1)
            |   +-input_scan=
            |     +-GraphTableScan
            |       +-column_list=$graph_table.[key#2, value#3]
            |       +-property_graph=aml
            |       +-input_scan=
            |       | +-GraphScan
            |       |   +-column_list=[$element_table.n#1]
            |       |   +-input_scan_list=
            |       |     +-GraphPathScan
            |       |       +-column_list=[$element_table.n#1]
            |       |       +-input_scan_list=
            |       |       | +-GraphNodeScan
            |       |       |   +-column_list=[$element_table.n#1]
            |       |       |   +-label_expr=
            |       |       |   | +-GraphLabelNaryExpr
            |       |       |   |   +-op=OR
            |       |       |   |   +-operand_list=
            |       |       |   |     +-GraphWildCardLabel
            |       |       |   |     +-GraphLabelNaryExpr
            |       |       |   |       +-op=NOT
            |       |       |   |       +-operand_list=
            |       |       |   |         +-GraphWildCardLabel
            |       |       |   +-target_element_table_list=[aml.Account,aml.Person,aml.Syndicate]
            |       |       +-head=$element_table.n#1
            |       |       +-tail=$element_table.n#1
            |       +-shape_expr_list=
            |         +-key#2 :=
            |         | +-GraphGetElementProperty
            |         |   +-type=UINT32
            |         |   +-expr=
            |         |   | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |         |   +-property=age(UINT32)
            |         |   +-property_name=
            |         |     +-Literal(type=STRING, value="age", has_explicit_type=TRUE)
            |         +-value#3 :=
            |           +-GraphGetElementProperty
            |             +-type=STRING
            |             +-expr=
            |             | +-ColumnRef(type=GRAPH_NODE(aml)<age UINT32, balance UINT64, birthday DATE, data BYTES, id INT64, name STRING, syndicateData ARRAY<INT64>, syndicateId INT64, syndicateName STRING>, column=$element_table.n#1)
            |             +-property=name(STRING)
            |             +-property_name=
            |               +-Literal(type=STRING, value="name", has_explicit_type=TRUE)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=UINT64, column=$orderby.$orderbycol1#4)
            |           +-is_descending=TRUE
            |           +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=$graph_table.value#3)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#8 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |     +-ColumnRef(type=STRING, column=$graph_table.value#3)
            |     +-$agg2#9 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=$graph_table.value#3)
            +-match_number_column=$match_recognize.$match_number#5
            +-match_row_number_column=$match_recognize.$match_row_number#6
            +-classifier_column=$match_recognize.$classifier#7
==

# Predicates need to be boolean
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a)
  DEFINE
    A AS Key + 1
)
--
ERROR: MATCH_RECOGNIZE DEFINE predicate should return type BOOL, but returns INT64 [at 6:10]
    A AS Key + 1
         ^
==

# Cannot access pattern variables in the DEFINE clause. They also hide external
# range variables.
select * from KeyValue a MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES max(length(value)) - min(length(value)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(a.value) >= 10
)
--
ERROR: Cannot access columns through pattern variables. [at 7:17]
    B AS length(a.value) >= 10
                ^
==

# Can access range variables when not shadowed by pattern variables, both in
# the MEASURES and DEFINE clauses.
select * from KeyValue t MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES min(t.value) AS m
  PATTERN (a)
  DEFINE
    A AS length(t.value) > 10
)
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t")
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#8 AS m [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#8]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#8]
        +-expr_list=
        | +-m#8 := ColumnRef(type=STRING, column=$aggregate.$agg1#7)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t")
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |           +-is_descending=TRUE
            |           +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
==

# Error on variable used in PATTERN that has no entry in DEFINE
select * from KeyValue t MATCH_RECOGNIZE(
  ORDER BY key DESC
  MEASURES min(t.value) AS m
  PATTERN (a b)
  DEFINE
    A AS length(t.value) > 10
)
--
ERROR: Pattern variable `b` is not defined in the DEFINE clause [at 4:14]
  PATTERN (a b)
             ^
==

# Pattern variable names are case-insensitive and can be quoted.
select x, length(x) from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES min(value) AS x
  PATTERN ( A (b|`A`) `x` `$ #` a )
  DEFINE
    a AS length(value) < 10,
    B AS length(value) >= 10,
    x AS true,
    `$ #` AS true
)
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
| +-$query.$col2#8 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7, $query.$col2#8]
    +-expr_list=
    | +-$col2#8 :=
    |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#7)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |           +-is_descending=TRUE
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="B"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="x"
            | | +-predicate=
            | |   +-Literal(type=BOOL, value=true)
            | +-MatchRecognizeVariableDefinition
            |   +-name="$ #"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=true)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternOperation
            |     | +-op_type=ALTERNATE
            |     | +-operand_list=
            |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     |   +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternVariableRef(name="x")
            |     +-MatchRecognizePatternVariableRef(name="$ #")
            |     +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#8 AS x [STRING]
| +-$query.$col2#9 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#8, $query.$col2#9]
    +-expr_list=
    | +-$col2#9 :=
    |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#8)
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#8]
        +-expr_list=
        | +-x#8 := ColumnRef(type=STRING, column=$aggregate.$agg1#7)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
            |   +-expr_list=
            |   | +-$orderbycol1#3 :=
            |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
            |           +-is_descending=TRUE
            |           +-null_order=NULLS_FIRST
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="B"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            | | +-name="x"
            | | +-predicate=
            | |   +-Literal(type=BOOL, value=true)
            | +-MatchRecognizeVariableDefinition
            |   +-name="$ #"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=true)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternOperation
            |     | +-op_type=ALTERNATE
            |     | +-operand_list=
            |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     |   +-MatchRecognizePatternVariableRef(name="a")
            |     +-MatchRecognizePatternVariableRef(name="x")
            |     +-MatchRecognizePatternVariableRef(name="$ #")
            |     +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
==

# Duplicate definition is an error, even if identical
select x, length(x) from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
  MEASURES min(value) AS x
  PATTERN ( A )
  DEFINE
    a AS length(value) < 10,
    a AS length(value) < 10
)
--
ERROR: Pattern variable `a` is defined multiple times [at 7:5]
    a AS length(value) < 10
    ^
==

# Error on unused variable
select x, length(x) from KeyValue MATCH_RECOGNIZE(
  ORDER BY key DESC
  MEASURES min(value) AS x
  PATTERN ( A )
  DEFINE
    a AS length(value) < 10,
    b AS length(value) >= 10
)
--
ERROR: Pattern variable `b` is defined but not used in the pattern [at 7:5]
    b AS length(value) >= 10
    ^
==

# On an operand of a join, with alternation
select x, length(x) from
  KeyValue MATCH_RECOGNIZE(
    ORDER BY {{key DESC|key + 1 DESC NULLS FIRST}}
    MEASURES min(value) AS x
    PATTERN ( A (B|A) X A )
    DEFINE
      A AS length(value) < 10,
      B AS length(value) >= 10,
      X AS true
  ) AS m1
INNER JOIN KeyValue
ON m1.x = value
--
ALTERNATION GROUP: key DESC
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
| +-$query.$col2#10 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7, $query.$col2#10]
    +-expr_list=
    | +-$col2#10 :=
    |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#7)
    +-input_scan=
      +-JoinScan
        +-column_list=[$match_recognize.x#7, KeyValue.Value#9]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[$match_recognize.x#7]
        |   +-expr_list=
        |   | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        |   +-input_scan=
        |     +-MatchRecognizeScan
        |       +-column_list=[$aggregate.$agg1#6]
        |       +-input_scan=
        |       | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |       +-analytic_function_group_list=
        |       | +-AnalyticFunctionGroup
        |       |   +-order_by=
        |       |     +-WindowOrdering
        |       |       +-order_by_item_list=
        |       |         +-OrderByItem
        |       |           +-column_ref=
        |       |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       |           +-is_descending=TRUE
        |       +-pattern_variable_definition_list=
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="A"
        |       | | +-predicate=
        |       | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="B"
        |       | | +-predicate=
        |       | |   +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       |   +-name="X"
        |       |   +-predicate=
        |       |     +-Literal(type=BOOL, value=true)
        |       +-pattern=
        |       | +-MatchRecognizePatternOperation
        |       |   +-op_type=CONCAT
        |       |   +-operand_list=
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternOperation
        |       |     | +-op_type=ALTERNATE
        |       |     | +-operand_list=
        |       |     |   +-MatchRecognizePatternVariableRef(name="B")
        |       |     |   +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternVariableRef(name="X")
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       +-after_match_skip_mode=END_OF_MATCH
        |       +-measure_group_list=
        |       | +-MeasureGroup
        |       |   +-aggregate_list=
        |       |     +-$agg1#6 :=
        |       |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
        |       |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       +-match_number_column=$match_recognize.$match_number#3
        |       +-match_row_number_column=$match_recognize.$match_row_number#4
        |       +-classifier_column=$match_recognize.$classifier#5
        +-right_scan=
        | +-TableScan(column_list=[KeyValue.Value#9], table=KeyValue, column_index_list=[1])
        +-join_expr=
          +-FunctionCall(GoogleSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=$match_recognize.x#7)
            +-ColumnRef(type=STRING, column=KeyValue.Value#9)
--
ALTERNATION GROUP: key + 1 DESC NULLS FIRST
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#8 AS x [STRING]
| +-$query.$col2#11 AS `$col2` [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#8, $query.$col2#11]
    +-expr_list=
    | +-$col2#11 :=
    |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
    |     +-ColumnRef(type=STRING, column=$match_recognize.x#8)
    +-input_scan=
      +-JoinScan
        +-column_list=[$match_recognize.x#8, KeyValue.Value#10]
        +-left_scan=
        | +-ProjectScan
        |   +-column_list=[$match_recognize.x#8]
        |   +-expr_list=
        |   | +-x#8 := ColumnRef(type=STRING, column=$aggregate.$agg1#7)
        |   +-input_scan=
        |     +-MatchRecognizeScan
        |       +-column_list=[$aggregate.$agg1#7]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $orderby.$orderbycol1#3]
        |       |   +-expr_list=
        |       |   | +-$orderbycol1#3 :=
        |       |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        |       |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
        |       |   |     +-Literal(type=INT64, value=1)
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
        |       +-analytic_function_group_list=
        |       | +-AnalyticFunctionGroup
        |       |   +-order_by=
        |       |     +-WindowOrdering
        |       |       +-order_by_item_list=
        |       |         +-OrderByItem
        |       |           +-column_ref=
        |       |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#3)
        |       |           +-is_descending=TRUE
        |       |           +-null_order=NULLS_FIRST
        |       +-pattern_variable_definition_list=
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="A"
        |       | | +-predicate=
        |       | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       | | +-name="B"
        |       | | +-predicate=
        |       | |   +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
        |       | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
        |       | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       | |     +-Literal(type=INT64, value=10)
        |       | +-MatchRecognizeVariableDefinition
        |       |   +-name="X"
        |       |   +-predicate=
        |       |     +-Literal(type=BOOL, value=true)
        |       +-pattern=
        |       | +-MatchRecognizePatternOperation
        |       |   +-op_type=CONCAT
        |       |   +-operand_list=
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternOperation
        |       |     | +-op_type=ALTERNATE
        |       |     | +-operand_list=
        |       |     |   +-MatchRecognizePatternVariableRef(name="B")
        |       |     |   +-MatchRecognizePatternVariableRef(name="A")
        |       |     +-MatchRecognizePatternVariableRef(name="X")
        |       |     +-MatchRecognizePatternVariableRef(name="A")
        |       +-after_match_skip_mode=END_OF_MATCH
        |       +-measure_group_list=
        |       | +-MeasureGroup
        |       |   +-aggregate_list=
        |       |     +-$agg1#7 :=
        |       |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
        |       |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
        |       +-match_number_column=$match_recognize.$match_number#4
        |       +-match_row_number_column=$match_recognize.$match_row_number#5
        |       +-classifier_column=$match_recognize.$classifier#6
        +-right_scan=
        | +-TableScan(column_list=[KeyValue.Value#10], table=KeyValue, column_index_list=[1])
        +-join_expr=
          +-FunctionCall(GoogleSQL:$equal(STRING, STRING) -> BOOL)
            +-ColumnRef(type=STRING, column=$match_recognize.x#8)
            +-ColumnRef(type=STRING, column=KeyValue.Value#10)
==

# Aggregation in DEFINE clause is not yet supported
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( A )
  DEFINE
    A AS value > MAX(value)
)
--

ERROR: Aggregate function MAX not allowed in MATCH_RECOGNIZE DEFINE predicate [at 6:18]
    A AS value > MAX(value)
                 ^
==

# Conditional evaluation is not yet supported
# Conditional on the whole MATCH_RECOGNIZE operation
[language_features=MAXIMUM,+MATCH_RECOGNIZE,+ENFORCE_CONDITIONAL_EVALUATION]
SELECT IF(key = 0, NULL,
        (select * from KeyValue MATCH_RECOGNIZE(
          ORDER BY 1/outer_tbl.key        # Could be a div by zero error
          MEASURES min(value) AS x
          PATTERN ( A B )
          DEFINE
            A AS length(value) < 10,
            B AS length(value) >= 10
        )))
FROM KeyValue outer_tbl
--
ERROR: Conditional evaluation is not supported with MATCH_RECOGNIZE [at 2:33]
        (select * from KeyValue MATCH_RECOGNIZE(
                                ^
==

# Conditional evaluation is not yet supported
# Conditional on aggregations in the MATCH_RECOGNIZE clause
[language_features=MAXIMUM,+MATCH_RECOGNIZE,+ENFORCE_CONDITIONAL_EVALUATION]
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY 1/key
  MEASURES IF(min(length(value)) > 0, min(1/length(value)), NULL) AS x
  PATTERN ( A B )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: Conditional evaluation is not supported with MATCH_RECOGNIZE [at 3:15]
  MEASURES IF(min(length(value)) > 0, min(1/length(value)), NULL) AS x
              ^
==

# Unaggregated column in MEASURES in the default ONE ROW PER MATCH mode.
select * from KeyValue t MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES {{|t.|A.}}value AS x
  PATTERN ( A )
  DEFINE
    A AS true
)
--
ALTERNATION GROUP: <empty>
--
ERROR: MATCH_RECOGNIZE MEASURES clause expression references column value which is neither grouped nor aggregated [at 3:12]
  MEASURES value AS x
           ^
--
ALTERNATION GROUP: t.
--
ERROR: MATCH_RECOGNIZE MEASURES clause expression references t.value which is neither grouped nor aggregated [at 3:12]
  MEASURES t.value AS x
           ^
--
ALTERNATION GROUP: A.
--
ERROR: Cannot access columns through pattern variables. [at 3:12]
  MEASURES A.value AS x
           ^
==

# Empty pattern as operand to quantification & other operations
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( ()+ a () (a|) )
  DEFINE
    A AS length(value) < 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternEmpty
            |     +-MatchRecognizePatternOperation
            |       +-op_type=ALTERNATE
            |       +-operand_list=
            |         +-MatchRecognizePatternVariableRef(name="A")
            |         +-MatchRecognizePatternEmpty
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Reluctant ? vs nested ?s
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( (a?)? )
  DEFINE
    A AS length(value) < 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternQuantification
            |   +-operand=
            |   | +-MatchRecognizePatternQuantification
            |   |   +-operand=
            |   |   | +-MatchRecognizePatternVariableRef(name="A")
            |   |   +-lower_bound=
            |   |   | +-Literal(type=INT64, value=0)
            |   |   +-upper_bound=
            |   |   | +-Literal(type=INT64, value=1)
            |   |   +-is_reluctant=FALSE
            |   +-lower_bound=
            |   | +-Literal(type=INT64, value=0)
            |   +-upper_bound=
            |   | +-Literal(type=INT64, value=1)
            |   +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Quantified patterns: Symbol quantifiers
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a+ (b)+? (a|)* (a|()b)*? a? b?? )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="B")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternOperation
            |     | |       +-op_type=CONCAT
            |     | |       +-operand_list=
            |     | |         +-MatchRecognizePatternEmpty
            |     | |         +-MatchRecognizePatternVariableRef(name="B")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-upper_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="B")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=0)
            |       +-upper_bound=
            |       | +-Literal(type=INT64, value=1)
            |       +-is_reluctant=TRUE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

[parameter_mode=positional]
[positional_parameter_types=int64,int64]
# Quantified patterns: Fixed quantifiers - Dedicated case for positional params
# Note how each quantifier has both of its bounds set to the same parameter.
# But the referenced parameters are different between the quantifiers.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{?} (a{?}) )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Parameter(type=INT64, position=1)
            |     | +-upper_bound=
            |     | | +-Parameter(type=INT64, position=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-lower_bound=
            |       | +-Parameter(type=INT64, position=2)
            |       +-upper_bound=
            |       | +-Parameter(type=INT64, position=2)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# This is a syntax error. This test is here to protect against regressions.
# If the syntax starts allowing richer syntax, even CAST(? AS INT64), the logic
# for SqlBuilder, which needs to avoid printing A{?} as A{?, ?} will break
# because it's hard to match general expressions.
[parameter_mode=positional]
[positional_parameter_types=int64,int64]
# Quantified patterns: Fixed quantifiers - Dedicated case for positional params
# Note how each quantifier has both of its bounds set to the same parameter.
# But the referenced parameters are different between the quantifiers.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{? + 1} )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Syntax error: Expected "," but got "+" [at 7:17]
  PATTERN ( a{? + 1} )
                ^
==

# This is a syntax error. This test is here to protect against regressions.
# If the syntax starts allowing richer syntax, even CAST(? AS INT64), the logic
# for SqlBuilder, which needs to avoid printing A{?} as A{?, ?} will break
# because it's hard to match general expressions.
[parameter_mode=positional]
[positional_parameter_types=int64,int64]
# Quantified patterns: Fixed quantifiers - Dedicated case for positional params
# Note how each quantifier has both of its bounds set to the same parameter.
# But the referenced parameters are different between the quantifiers.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{CAST(? AS INT64)} )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Syntax error: Expected "," but got keyword CAST [at 7:15]
  PATTERN ( a{CAST(? AS INT64)} )
              ^
==

# Quantified patterns: 2-bounded quantifiers
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1, @test_param_int64} a{2, 4}? (a|b()b|){ , }? b{@test_param_int64, }? a { , 3} )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-upper_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=2)
            |     | +-upper_bound=
            |     | | +-Literal(type=INT64, value=4)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternOperation
            |     | |     | +-op_type=CONCAT
            |     | |     | +-operand_list=
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     |   +-MatchRecognizePatternEmpty
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="B")
            |     | +-lower_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-is_reluctant=TRUE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=0)
            |       +-upper_bound=
            |       | +-Literal(type=INT64, value=3)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Quantified patterns: Fixed quantifiers
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1} (a|b()b|){@test_param_int64} a{ 0xaF } )
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="A")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-upper_bound=
            |     | | +-Literal(type=INT64, value=1)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternOperation
            |     | |   +-op_type=ALTERNATE
            |     | |   +-operand_list=
            |     | |     +-MatchRecognizePatternVariableRef(name="A")
            |     | |     +-MatchRecognizePatternOperation
            |     | |     | +-op_type=CONCAT
            |     | |     | +-operand_list=
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     |   +-MatchRecognizePatternEmpty
            |     | |     |   +-MatchRecognizePatternVariableRef(name="B")
            |     | |     +-MatchRecognizePatternEmpty
            |     | +-lower_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-upper_bound=
            |     | | +-Parameter(type=INT64, name="test_param_int64")
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=175)
            |       +-upper_bound=
            |       | +-Literal(type=INT64, value=175)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Quantifier bound must be a literal or parameter
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1+1} )
  DEFINE
    A AS length(value) < 10
)
--

ERROR: Syntax error: Expected "," but got "+" [at 4:16]
  PATTERN ( a{1+1} )
               ^
==

# Quantifiers with negative values. This is repeating a case in parser tests
# to catch potential regressions if the syntax is relaxed.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{-1} )
  DEFINE
    A AS length(value) < 10
)
--

ERROR: Syntax error: Expected "," but got "-" [at 4:15]
  PATTERN ( a{-1} )
              ^
==

# Quantifier bound of the wrong type, or NULL
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{ {{NULL|@test_param_bool|@test_param_string|1.6|CAST(1 AS UINT32)}} } )
  DEFINE
    A AS length(value) < 10
)
--

ALTERNATION GROUP: NULL
--
ERROR: Syntax error: Expected "," but got keyword NULL [at 4:16]
  PATTERN ( a{ NULL } )
               ^
--
ALTERNATION GROUP: @test_param_bool
--
ERROR: MATCH_RECOGNIZE quantifier bound expects an integer literal or parameter [at 4:16]
  PATTERN ( a{ @test_param_bool } )
               ^
--
ALTERNATION GROUP: @test_param_string
--
ERROR: MATCH_RECOGNIZE quantifier bound expects an integer literal or parameter [at 4:16]
  PATTERN ( a{ @test_param_string } )
               ^
--
ALTERNATION GROUP: 1.6
--
ERROR: Syntax error: Expected "," but got floating point literal "1.6" [at 4:16]
  PATTERN ( a{ 1.6 } )
               ^
--
ALTERNATION GROUP: CAST(1 AS UINT32)
--
ERROR: Syntax error: Expected "," but got keyword CAST [at 4:16]
  PATTERN ( a{ CAST(1 AS UINT32) } )
               ^
==

# Quantifiers with bad values, detectable because both are literals.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{3, 1} )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Quantifier upper bound cannot be smaller than the lower bound [at 4:14]
  PATTERN ( a{3, 1} )
             ^
==

# ORDER BY cannot have aggregations, analytic functions, nor ordinals.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY {{max(key)|max(key) OVER(ORDER BY value)|1}}
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ALTERNATION GROUP: max(key)
--
ERROR: Aggregate function MAX not allowed in MATCH_RECOGNIZE ORDER BY clause [at 2:12]
  ORDER BY max(key)
           ^
--
ALTERNATION GROUP: max(key) OVER(ORDER BY value)
--
ERROR: Analytic function not allowed in MATCH_RECOGNIZE ORDER BY clause [at 2:12]
  ORDER BY max(key) OVER(ORDER BY value)
           ^
--
ALTERNATION GROUP: 1
--
ERROR: Ordinals are not allowed in MATCH_RECOGNIZE ORDER BY clause [at 2:12]
  ORDER BY 1
           ^
==

[language_features=MAXIMUM,-JSON_TYPE_COMPARISON]
# ORDER BY expressions must be of an orderable type. JSON is not orderable.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY JSON'{"f":1}'
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Ordering by expressions of type JSON is not allowed [at 3:12]
  ORDER BY JSON'{"f":1}'
           ^
==

# ORDER BY with collation
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value COLLATE "en_US"
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.x#7 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.x#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.x#7]
        +-expr_list=
        | +-x#7 := ColumnRef(type=STRING, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |           | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |           +-collation_name=
            |             +-Literal(type=STRING, value="en_US")
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Computed partitioning columns
# TODO: PARTITION BY..AS syntax (esp with the alias covering an input column)
select * from KeyValue MATCH_RECOGNIZE(
  PARTITION BY key * 2
  ORDER BY value || value
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$partitionby.$partitionbycol1#3 AS `$partition_by_col1` [INT64]
| +-$match_recognize.x#9 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.$partitionbycol1#3, $match_recognize.x#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.$partitionbycol1#3, $match_recognize.x#9]
        +-expr_list=
        | +-x#9 := ColumnRef(type=STRING, column=$aggregate.$agg1#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.$partitionbycol1#3, $aggregate.$agg1#8]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.$partitionbycol1#3, $orderby.$orderbycol1#4]
            |   +-expr_list=
            |   | +-$partitionbycol1#3 :=
            |   | | +-FunctionCall(GoogleSQL:$multiply(INT64, INT64) -> INT64)
            |   | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | |   +-Literal(type=INT64, value=2)
            |   | +-$orderbycol1#4 :=
            |   |   +-FunctionCall(GoogleSQL:concat(STRING, repeated(1) STRING) -> STRING)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-partition_by=
            |   | +-WindowPartitioning
            |   |   +-partition_by_list=
            |   |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol1#3)
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#8 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#5
            +-match_row_number_column=$match_recognize.$match_row_number#6
            +-classifier_column=$match_recognize.$classifier#7
==

select key, x from KeyValue MATCH_RECOGNIZE(
  PARTITION BY key
  ORDER BY value || value
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$partitionby.key#3 AS key [INT64]
| +-$match_recognize.x#9 AS x [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.key#3, $match_recognize.x#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.key#3, $match_recognize.x#9]
        +-expr_list=
        | +-x#9 := ColumnRef(type=STRING, column=$aggregate.$agg1#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.key#3, $aggregate.$agg1#8]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.key#3, $orderby.$orderbycol1#4]
            |   +-expr_list=
            |   | +-key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | +-$orderbycol1#4 :=
            |   |   +-FunctionCall(GoogleSQL:concat(STRING, repeated(1) STRING) -> STRING)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-partition_by=
            |   | +-WindowPartitioning
            |   |   +-partition_by_list=
            |   |     +-ColumnRef(type=INT64, column=$partitionby.key#3)
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=$orderby.$orderbycol1#4)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#8 :=
            |       +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#5
            +-match_row_number_column=$match_recognize.$match_row_number#6
            +-classifier_column=$match_recognize.$classifier#7
==

# PARTITION BY cannot have aggregations, analytic functions, nor ordinals.
select * from KeyValue MATCH_RECOGNIZE(
  PARTITION BY {{max(key)|max(key) OVER(ORDER BY value)|1}}
  ORDER BY value
  MEASURES min(value) AS x
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ALTERNATION GROUP: max(key)
--
ERROR: Aggregate function MAX not allowed in MATCH_RECOGNIZE PARTITION BY clause [at 2:16]
  PARTITION BY max(key)
               ^
--
ALTERNATION GROUP: max(key) OVER(ORDER BY value)
--
ERROR: Analytic function not allowed in MATCH_RECOGNIZE PARTITION BY clause [at 2:16]
  PARTITION BY max(key) OVER(ORDER BY value)
               ^
--
ALTERNATION GROUP: 1
--
ERROR: Ordinals are not allowed in MATCH_RECOGNIZE PARTITION BY clause [at 2:16]
  PARTITION BY 1
               ^
==

# Regression test where ValidateResolvedComputedColumn*LIST* was called from
# the loop, validating the whole measure list for each measure, instead of
# individually. Trees like subqueries under those measures could hit column ID
# uniqueness checks.
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES min((select Key from KeyValue)) AS m1, max((select Key from KeyValue)) AS m2
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--

QueryStmt
+-output_column_list=
| +-$match_recognize.m1#9 AS m1 [INT64]
| +-$match_recognize.m2#13 AS m2 [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[m1#9, m2#13]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[m1#9, m2#13]
        +-expr_list=
        | +-m1#9 := ColumnRef(type=INT64, column=$aggregate.$agg1#8)
        | +-m2#13 := ColumnRef(type=INT64, column=$aggregate.$agg2#12)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#8, $agg2#12]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#8 :=
            |     | +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |     |   +-SubqueryExpr
            |     |     +-type=INT64
            |     |     +-subquery_type=SCALAR
            |     |     +-subquery=
            |     |       +-ProjectScan
            |     |         +-column_list=[KeyValue.Key#6]
            |     |         +-input_scan=
            |     |           +-TableScan(column_list=[KeyValue.Key#6], table=KeyValue, column_index_list=[0])
            |     +-$agg2#12 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-SubqueryExpr
            |           +-type=INT64
            |           +-subquery_type=SCALAR
            |           +-subquery=
            |             +-ProjectScan
            |               +-column_list=[KeyValue.Key#10]
            |               +-input_scan=
            |                 +-TableScan(column_list=[KeyValue.Key#10], table=KeyValue, column_index_list=[0])
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Repeated partition column
select key from KeyValue MATCH_RECOGNIZE(
  PARTITION BY key, key
  ORDER BY value
  MEASURES min(value) AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
ERROR: Column name key is ambiguous [at 1:8]
select key from KeyValue MATCH_RECOGNIZE(
       ^
==

# ORDER BY in aggregate function call
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES ARRAY_AGG(value ORDER BY value) AS m
  PATTERN ( A A )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=ARRAY<STRING>, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:array_agg(STRING) -> ARRAY<STRING>)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |         +-order_by_item_list=
            |           +-OrderByItem
            |             +-column_ref=
            |               +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# DML column in partition by
DELETE FROM KeyValue WHERE
  (
    WITH t AS (SELECT 1 AS x, 2 AS y)
    select Key + m from t MATCH_RECOGNIZE(
      PARTITION BY Key            # reference a DML column
      ORDER BY y
      MEASURES min(y) AS m
      PATTERN ( a a )
      DEFINE
        A AS y < 10
    )
  ) > 0
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
    +-SubqueryExpr
    | +-type=INT64
    | +-subquery_type=SCALAR
    | +-parameter_list=
    | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | +-subquery=
    |   +-WithScan
    |     +-column_list=[$expr_subquery.$col1#13]
    |     +-with_entry_list=
    |     | +-WithEntry
    |     |   +-with_query_name="t"
    |     |   +-with_subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=t.[x#3, y#4]
    |     |       +-expr_list=
    |     |       | +-x#3 := Literal(type=INT64, value=1)
    |     |       | +-y#4 := Literal(type=INT64, value=2)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-query=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#13]
    |         +-expr_list=
    |         | +-$col1#13 :=
    |         |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=$partitionby.Key#7)
    |         |     +-ColumnRef(type=INT64, column=$match_recognize.m#12)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$partitionby.Key#7, $match_recognize.m#12]
    |             +-expr_list=
    |             | +-m#12 := ColumnRef(type=INT64, column=$aggregate.$agg1#11)
    |             +-input_scan=
    |               +-MatchRecognizeScan
    |                 +-column_list=[$partitionby.Key#7, $aggregate.$agg1#11]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[t.x#5, t.y#6, $partitionby.Key#7]
    |                 |   +-expr_list=
    |                 |   | +-Key#7 := ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |                 |   +-input_scan=
    |                 |     +-WithRefScan(column_list=t.[x#5, y#6], with_query_name="t")
    |                 +-analytic_function_group_list=
    |                 | +-AnalyticFunctionGroup
    |                 |   +-partition_by=
    |                 |   | +-WindowPartitioning
    |                 |   |   +-partition_by_list=
    |                 |   |     +-ColumnRef(type=INT64, column=$partitionby.Key#7)
    |                 |   +-order_by=
    |                 |     +-WindowOrdering
    |                 |       +-order_by_item_list=
    |                 |         +-OrderByItem
    |                 |           +-column_ref=
    |                 |             +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-pattern_variable_definition_list=
    |                 | +-MatchRecognizeVariableDefinition
    |                 |   +-name="A"
    |                 |   +-predicate=
    |                 |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
    |                 |       +-ColumnRef(type=INT64, column=t.y#6)
    |                 |       +-Literal(type=INT64, value=10)
    |                 +-pattern=
    |                 | +-MatchRecognizePatternOperation
    |                 |   +-op_type=CONCAT
    |                 |   +-operand_list=
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 +-after_match_skip_mode=END_OF_MATCH
    |                 +-measure_group_list=
    |                 | +-MeasureGroup
    |                 |   +-aggregate_list=
    |                 |     +-$agg1#11 :=
    |                 |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
    |                 |         +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-match_number_column=$match_recognize.$match_number#8
    |                 +-match_row_number_column=$match_recognize.$match_row_number#9
    |                 +-classifier_column=$match_recognize.$classifier#10
    +-Literal(type=INT64, value=0)
==

# DML column in partition by with duplication
DELETE FROM KeyValue WHERE
  (
    WITH t AS (SELECT 1 AS x, 2 AS y)
    select Key + m from t MATCH_RECOGNIZE(
      PARTITION BY value, value            # reference a DML column
      ORDER BY y
      MEASURES min(y) AS m
      PATTERN ( a a )
      DEFINE
        A AS y < 10
    )
  ) > 0
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
+-column_access_list=READ,READ
+-where_expr=
  +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
    +-SubqueryExpr
    | +-type=INT64
    | +-subquery_type=SCALAR
    | +-parameter_list=
    | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
    | +-subquery=
    |   +-WithScan
    |     +-column_list=[$expr_subquery.$col1#14]
    |     +-with_entry_list=
    |     | +-WithEntry
    |     |   +-with_query_name="t"
    |     |   +-with_subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=t.[x#3, y#4]
    |     |       +-expr_list=
    |     |       | +-x#3 := Literal(type=INT64, value=1)
    |     |       | +-y#4 := Literal(type=INT64, value=2)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-query=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#14]
    |         +-expr_list=
    |         | +-$col1#14 :=
    |         |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |     +-ColumnRef(type=INT64, column=$match_recognize.m#13)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$partitionby.value#7, $partitionby.value#8, $match_recognize.m#13]
    |             +-expr_list=
    |             | +-m#13 := ColumnRef(type=INT64, column=$aggregate.$agg1#12)
    |             +-input_scan=
    |               +-MatchRecognizeScan
    |                 +-column_list=[$partitionby.value#7, $partitionby.value#8, $aggregate.$agg1#12]
    |                 +-input_scan=
    |                 | +-ProjectScan
    |                 |   +-column_list=[t.x#5, t.y#6, $partitionby.value#7, $partitionby.value#8]
    |                 |   +-expr_list=
    |                 |   | +-value#7 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |                 |   | +-value#8 := ColumnRef(type=STRING, column=KeyValue.Value#2, is_correlated=TRUE)
    |                 |   +-input_scan=
    |                 |     +-WithRefScan(column_list=t.[x#5, y#6], with_query_name="t")
    |                 +-analytic_function_group_list=
    |                 | +-AnalyticFunctionGroup
    |                 |   +-partition_by=
    |                 |   | +-WindowPartitioning
    |                 |   |   +-partition_by_list=
    |                 |   |     +-ColumnRef(type=STRING, column=$partitionby.value#7)
    |                 |   |     +-ColumnRef(type=STRING, column=$partitionby.value#8)
    |                 |   +-order_by=
    |                 |     +-WindowOrdering
    |                 |       +-order_by_item_list=
    |                 |         +-OrderByItem
    |                 |           +-column_ref=
    |                 |             +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-pattern_variable_definition_list=
    |                 | +-MatchRecognizeVariableDefinition
    |                 |   +-name="A"
    |                 |   +-predicate=
    |                 |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
    |                 |       +-ColumnRef(type=INT64, column=t.y#6)
    |                 |       +-Literal(type=INT64, value=10)
    |                 +-pattern=
    |                 | +-MatchRecognizePatternOperation
    |                 |   +-op_type=CONCAT
    |                 |   +-operand_list=
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 +-after_match_skip_mode=END_OF_MATCH
    |                 +-measure_group_list=
    |                 | +-MeasureGroup
    |                 |   +-aggregate_list=
    |                 |     +-$agg1#12 :=
    |                 |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
    |                 |         +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-match_number_column=$match_recognize.$match_number#9
    |                 +-match_row_number_column=$match_recognize.$match_row_number#10
    |                 +-classifier_column=$match_recognize.$classifier#11
    +-Literal(type=INT64, value=0)
==

# DML column referenced in measures, including with scoping to variables.
DELETE FROM KeyValue WHERE
  (
    WITH t AS (SELECT 1 AS x, 2 AS y)
    select Key + m from t MATCH_RECOGNIZE(
      ORDER BY y
      MEASURES min({{y|a.y}} + key) + key AS m
      PATTERN ( a a )
      DEFINE
        A AS y < 10
    )
  ) > 0
--

ALTERNATION GROUP: y
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
    +-SubqueryExpr
    | +-type=INT64
    | +-subquery_type=SCALAR
    | +-parameter_list=
    | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | +-subquery=
    |   +-WithScan
    |     +-column_list=[$expr_subquery.$col1#12]
    |     +-with_entry_list=
    |     | +-WithEntry
    |     |   +-with_query_name="t"
    |     |   +-with_subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=t.[x#3, y#4]
    |     |       +-expr_list=
    |     |       | +-x#3 := Literal(type=INT64, value=1)
    |     |       | +-y#4 := Literal(type=INT64, value=2)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-query=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#12]
    |         +-expr_list=
    |         | +-$col1#12 :=
    |         |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |     +-ColumnRef(type=INT64, column=$match_recognize.m#11)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$match_recognize.m#11]
    |             +-expr_list=
    |             | +-m#11 :=
    |             |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |             |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#10)
    |             |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             +-input_scan=
    |               +-MatchRecognizeScan
    |                 +-column_list=[$aggregate.$agg1#10]
    |                 +-input_scan=
    |                 | +-WithRefScan(column_list=t.[x#5, y#6], with_query_name="t")
    |                 +-analytic_function_group_list=
    |                 | +-AnalyticFunctionGroup
    |                 |   +-order_by=
    |                 |     +-WindowOrdering
    |                 |       +-order_by_item_list=
    |                 |         +-OrderByItem
    |                 |           +-column_ref=
    |                 |             +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-pattern_variable_definition_list=
    |                 | +-MatchRecognizeVariableDefinition
    |                 |   +-name="A"
    |                 |   +-predicate=
    |                 |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
    |                 |       +-ColumnRef(type=INT64, column=t.y#6)
    |                 |       +-Literal(type=INT64, value=10)
    |                 +-pattern=
    |                 | +-MatchRecognizePatternOperation
    |                 |   +-op_type=CONCAT
    |                 |   +-operand_list=
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 +-after_match_skip_mode=END_OF_MATCH
    |                 +-measure_group_list=
    |                 | +-MeasureGroup
    |                 |   +-aggregate_list=
    |                 |     +-$agg1#10 :=
    |                 |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
    |                 |         +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |                 |           +-ColumnRef(type=INT64, column=t.y#6)
    |                 |           +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |                 +-match_number_column=$match_recognize.$match_number#7
    |                 +-match_row_number_column=$match_recognize.$match_row_number#8
    |                 +-classifier_column=$match_recognize.$classifier#9
    +-Literal(type=INT64, value=0)
--
ALTERNATION GROUP: a.y
--
DeleteStmt
+-table_scan=
| +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
+-column_access_list=READ
+-where_expr=
  +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
    +-SubqueryExpr
    | +-type=INT64
    | +-subquery_type=SCALAR
    | +-parameter_list=
    | | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
    | +-subquery=
    |   +-WithScan
    |     +-column_list=[$expr_subquery.$col1#12]
    |     +-with_entry_list=
    |     | +-WithEntry
    |     |   +-with_query_name="t"
    |     |   +-with_subquery=
    |     |     +-ProjectScan
    |     |       +-column_list=t.[x#3, y#4]
    |     |       +-expr_list=
    |     |       | +-x#3 := Literal(type=INT64, value=1)
    |     |       | +-y#4 := Literal(type=INT64, value=2)
    |     |       +-input_scan=
    |     |         +-SingleRowScan
    |     +-query=
    |       +-ProjectScan
    |         +-column_list=[$expr_subquery.$col1#12]
    |         +-expr_list=
    |         | +-$col1#12 :=
    |         |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |         |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |         |     +-ColumnRef(type=INT64, column=$match_recognize.m#11)
    |         +-input_scan=
    |           +-ProjectScan
    |             +-column_list=[$match_recognize.m#11]
    |             +-expr_list=
    |             | +-m#11 :=
    |             |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |             |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#10)
    |             |     +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |             +-input_scan=
    |               +-MatchRecognizeScan
    |                 +-column_list=[$aggregate.$agg1#10]
    |                 +-input_scan=
    |                 | +-WithRefScan(column_list=t.[x#5, y#6], with_query_name="t")
    |                 +-analytic_function_group_list=
    |                 | +-AnalyticFunctionGroup
    |                 |   +-order_by=
    |                 |     +-WindowOrdering
    |                 |       +-order_by_item_list=
    |                 |         +-OrderByItem
    |                 |           +-column_ref=
    |                 |             +-ColumnRef(type=INT64, column=t.y#6)
    |                 +-pattern_variable_definition_list=
    |                 | +-MatchRecognizeVariableDefinition
    |                 |   +-name="A"
    |                 |   +-predicate=
    |                 |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
    |                 |       +-ColumnRef(type=INT64, column=t.y#6)
    |                 |       +-Literal(type=INT64, value=10)
    |                 +-pattern=
    |                 | +-MatchRecognizePatternOperation
    |                 |   +-op_type=CONCAT
    |                 |   +-operand_list=
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 |     +-MatchRecognizePatternVariableRef(name="A")
    |                 +-after_match_skip_mode=END_OF_MATCH
    |                 +-measure_group_list=
    |                 | +-MeasureGroup
    |                 |   +-pattern_variable_ref=
    |                 |   | +-MatchRecognizePatternVariableRef(name="A")
    |                 |   +-aggregate_list=
    |                 |     +-$agg1#10 :=
    |                 |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
    |                 |         +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
    |                 |           +-ColumnRef(type=INT64, column=t.y#6)
    |                 |           +-ColumnRef(type=INT64, column=KeyValue.Key#1, is_correlated=TRUE)
    |                 +-match_number_column=$match_recognize.$match_number#7
    |                 +-match_row_number_column=$match_recognize.$match_row_number#8
    |                 +-classifier_column=$match_recognize.$classifier#9
    +-Literal(type=INT64, value=0)
==

# Modifiers on the measure aggregations
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES array_agg(
              value
              RESPECT NULLS
              HAVING MAX fn_optional_any(value)
              ORDER BY fn_on_string(value)
              LIMIT @test_param_int64
            ) AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#8 AS m [ARRAY<STRING>]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#8]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#8]
        +-expr_list=
        | +-m#8 := ColumnRef(type=ARRAY<STRING>, column=$aggregate.$agg1#7)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Value#2, $orderby.$orderbycol1#6]
            |   +-expr_list=
            |   | +-$orderbycol1#6 :=
            |   |   +-FunctionCall(sample_functions:fn_on_string(STRING) -> BOOL)
            |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |   +-input_scan=
            |     +-TableScan(column_list=[KeyValue.Value#2], table=KeyValue, column_index_list=[1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |       +-AggregateFunctionCall(GoogleSQL:array_agg(STRING) -> ARRAY<STRING>)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |         +-null_handling_modifier=RESPECT_NULLS
            |         +-having_modifier=
            |         | +-AggregateHavingModifier
            |         |   +-kind=MAX
            |         |   +-having_expr=
            |         |     +-FunctionCall(sample_functions:fn_optional_any(optional(1) STRING) -> STRING)
            |         |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |         +-order_by_item_list=
            |         | +-OrderByItem
            |         |   +-column_ref=
            |         |     +-ColumnRef(type=BOOL, column=$orderby.$orderbycol1#6)
            |         +-limit=
            |           +-Parameter(type=INT64, name="test_param_int64")
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Disallows window functions in MEASURES for ONE ROW PER MATCH
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES
    min(value) OVER (PARTITION BY fn_on_string(value) ORDER BY fn_optional_any(value)) AS m2
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--

ERROR: Analytic function not allowed in MATCH_RECOGNIZE MEASURES clause [at 4:5]
    min(value) OVER (PARTITION BY fn_on_string(value) ORDER BY fn_optional_an...
    ^
==

# Allows window functions in a subquery in MEASURES
WITH t AS (SELECT 1 AS x, 2 AS y)
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY value
  MEASURES
    min(length(value)) + (SELECT max(x) OVER(ORDER BY y) FROM t) AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#13 AS m [INT64]
+-query=
  +-WithScan
    +-column_list=[$match_recognize.m#13]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[x#1, y#2]
    |       +-expr_list=
    |       | +-x#1 := Literal(type=INT64, value=1)
    |       | +-y#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=[$match_recognize.m#13]
        +-input_scan=
          +-ProjectScan
            +-column_list=[$match_recognize.m#13]
            +-expr_list=
            | +-m#13 :=
            |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#8)
            |     +-SubqueryExpr
            |       +-type=INT64
            |       +-subquery_type=SCALAR
            |       +-subquery=
            |         +-ProjectScan
            |           +-column_list=[$analytic.$analytic1#12]
            |           +-input_scan=
            |             +-AnalyticScan
            |               +-column_list=[t.x#9, t.y#10, $analytic.$analytic1#12]
            |               +-input_scan=
            |               | +-WithRefScan(column_list=t.[x#9, y#10], with_query_name="t")
            |               +-function_group_list=
            |                 +-AnalyticFunctionGroup
            |                   +-order_by=
            |                   | +-WindowOrdering
            |                   |   +-order_by_item_list=
            |                   |     +-OrderByItem
            |                   |       +-column_ref=
            |                   |         +-ColumnRef(type=INT64, column=t.y#10)
            |                   +-analytic_function_list=
            |                     +-$analytic1#12 :=
            |                       +-AnalyticFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |                         +-ColumnRef(type=INT64, column=t.x#9)
            |                         +-window_frame=
            |                           +-WindowFrame(frame_unit=RANGE)
            |                             +-start_expr=
            |                             | +-WindowFrameExpr(boundary_type=UNBOUNDED PRECEDING)
            |                             +-end_expr=
            |                               +-WindowFrameExpr(boundary_type=CURRENT ROW)
            +-input_scan=
              +-MatchRecognizeScan
                +-column_list=[$aggregate.$agg1#8]
                +-input_scan=
                | +-TableScan(column_list=[KeyValue.Value#4], table=KeyValue, column_index_list=[1])
                +-analytic_function_group_list=
                | +-AnalyticFunctionGroup
                |   +-order_by=
                |     +-WindowOrdering
                |       +-order_by_item_list=
                |         +-OrderByItem
                |           +-column_ref=
                |             +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                +-pattern_variable_definition_list=
                | +-MatchRecognizeVariableDefinition
                |   +-name="A"
                |   +-predicate=
                |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
                |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
                |       | +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                |       +-Literal(type=INT64, value=10)
                +-pattern=
                | +-MatchRecognizePatternOperation
                |   +-op_type=CONCAT
                |   +-operand_list=
                |     +-MatchRecognizePatternVariableRef(name="A")
                |     +-MatchRecognizePatternVariableRef(name="A")
                +-after_match_skip_mode=END_OF_MATCH
                +-measure_group_list=
                | +-MeasureGroup
                |   +-aggregate_list=
                |     +-$agg1#8 :=
                |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
                |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
                |           +-ColumnRef(type=STRING, column=KeyValue.Value#4)
                +-match_number_column=$match_recognize.$match_number#5
                +-match_row_number_column=$match_recognize.$match_row_number#6
                +-classifier_column=$match_recognize.$classifier#7
==

# Trivial measures with no aggregations. No aggregations in the measures_list,
# so SqlBuilder needs to add a dummy measure to generate a valid query.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY Key
  MEASURES 1 AS one
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.one#6 AS one [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.one#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.one#6]
        +-expr_list=
        | +-one#6 := Literal(type=INT64, value=1)
        +-input_scan=
          +-MatchRecognizeScan
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Correct error when ordinals are out of range
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  PARTITION BY Key
  ORDER BY value
  MEASURES 1 AS m
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
ORDER BY 1, 2, 3
--
ERROR: ORDER BY is out of SELECT column number range: 3 [at 9:16]
ORDER BY 1, 2, 3
               ^
==

# Partition by a correlated column, with duplication
# Note that x is correlated, and is duplicated, and there's a measure with the
# same name.
WITH t AS (SELECT 1 AS x, 2 AS y)
SELECT * FROM t AS outer_t
WHERE
  x < (SELECT y+length(m)
        FROM KeyValue MATCH_RECOGNIZE(
          PARTITION BY outer_t.y, x, x
          ORDER BY value
          MEASURES min(value) AS m, max(value) AS x
          PATTERN ( a a )
          DEFINE
            A AS length(value) < 10
        )
      )
--
QueryStmt
+-output_column_list=
| +-t.x#3 AS x [INT64]
| +-t.y#4 AS y [INT64]
+-query=
  +-WithScan
    +-column_list=t.[x#3, y#4]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[x#1, y#2]
    |       +-expr_list=
    |       | +-x#1 := Literal(type=INT64, value=1)
    |       | +-y#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=t.[x#3, y#4]
        +-input_scan=
          +-FilterScan
            +-column_list=t.[x#3, y#4]
            +-input_scan=
            | +-WithRefScan(column_list=t.[x#3, y#4], with_query_name="t")
            +-filter_expr=
              +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
                +-ColumnRef(type=INT64, column=t.x#3)
                +-SubqueryExpr
                  +-type=INT64
                  +-subquery_type=SCALAR
                  +-parameter_list=
                  | +-ColumnRef(type=INT64, column=t.x#3)
                  | +-ColumnRef(type=INT64, column=t.y#4)
                  +-subquery=
                    +-ProjectScan
                      +-column_list=[$expr_subquery.$col1#17]
                      +-expr_list=
                      | +-$col1#17 :=
                      |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
                      |     +-ColumnRef(type=INT64, column=$partitionby.y#7)
                      |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
                      |       +-ColumnRef(type=STRING, column=$match_recognize.m#14)
                      +-input_scan=
                        +-ProjectScan
                          +-column_list=[$partitionby.y#7, $partitionby.x#8, $partitionby.x#9, $match_recognize.m#14, $match_recognize.x#16]
                          +-expr_list=
                          | +-m#14 := ColumnRef(type=STRING, column=$aggregate.$agg1#13)
                          | +-x#16 := ColumnRef(type=STRING, column=$aggregate.$agg2#15)
                          +-input_scan=
                            +-MatchRecognizeScan
                              +-column_list=[$partitionby.y#7, $partitionby.x#8, $partitionby.x#9, $aggregate.$agg1#13, $aggregate.$agg2#15]
                              +-input_scan=
                              | +-ProjectScan
                              |   +-column_list=[KeyValue.Value#6, $partitionby.y#7, $partitionby.x#8, $partitionby.x#9]
                              |   +-expr_list=
                              |   | +-y#7 := ColumnRef(type=INT64, column=t.y#4, is_correlated=TRUE)
                              |   | +-x#8 := ColumnRef(type=INT64, column=t.x#3, is_correlated=TRUE)
                              |   | +-x#9 := ColumnRef(type=INT64, column=t.x#3, is_correlated=TRUE)
                              |   +-input_scan=
                              |     +-TableScan(column_list=[KeyValue.Value#6], table=KeyValue, column_index_list=[1])
                              +-analytic_function_group_list=
                              | +-AnalyticFunctionGroup
                              |   +-partition_by=
                              |   | +-WindowPartitioning
                              |   |   +-partition_by_list=
                              |   |     +-ColumnRef(type=INT64, column=$partitionby.y#7)
                              |   |     +-ColumnRef(type=INT64, column=$partitionby.x#8)
                              |   |     +-ColumnRef(type=INT64, column=$partitionby.x#9)
                              |   +-order_by=
                              |     +-WindowOrdering
                              |       +-order_by_item_list=
                              |         +-OrderByItem
                              |           +-column_ref=
                              |             +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                              +-pattern_variable_definition_list=
                              | +-MatchRecognizeVariableDefinition
                              |   +-name="A"
                              |   +-predicate=
                              |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
                              |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
                              |       | +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                              |       +-Literal(type=INT64, value=10)
                              +-pattern=
                              | +-MatchRecognizePatternOperation
                              |   +-op_type=CONCAT
                              |   +-operand_list=
                              |     +-MatchRecognizePatternVariableRef(name="A")
                              |     +-MatchRecognizePatternVariableRef(name="A")
                              +-after_match_skip_mode=END_OF_MATCH
                              +-measure_group_list=
                              | +-MeasureGroup
                              |   +-aggregate_list=
                              |     +-$agg1#13 :=
                              |     | +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
                              |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                              |     +-$agg2#15 :=
                              |       +-AggregateFunctionCall(GoogleSQL:max(STRING) -> STRING)
                              |         +-ColumnRef(type=STRING, column=KeyValue.Value#6)
                              +-match_number_column=$match_recognize.$match_number#10
                              +-match_row_number_column=$match_recognize.$match_row_number#11
                              +-classifier_column=$match_recognize.$classifier#12
==

# Partition by duplicate columns
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  PARTITION BY Key, Key, Key+1, Key+1
  ORDER BY value
  MEASURES min(value) AS Key, max(value) AS Key
  PATTERN ( a a )
  DEFINE
    A AS length(value) < 10
)
--
QueryStmt
+-output_column_list=
| +-$partitionby.Key#3 AS Key [INT64]
| +-$partitionby.Key#4 AS Key [INT64]
| +-$partitionby.$partitionbycol3#5 AS `$partition_by_col3` [INT64]
| +-$partitionby.$partitionbycol4#6 AS `$partition_by_col4` [INT64]
| +-$match_recognize.Key#11 AS Key [STRING]
| +-$match_recognize.Key#13 AS Key [STRING]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6, $match_recognize.Key#11, $match_recognize.Key#13]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6, $match_recognize.Key#11, $match_recognize.Key#13]
        +-expr_list=
        | +-Key#11 := ColumnRef(type=STRING, column=$aggregate.$agg1#10)
        | +-Key#13 := ColumnRef(type=STRING, column=$aggregate.$agg2#12)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6, $aggregate.$agg1#10, $aggregate.$agg2#12]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.Key#3, $partitionby.Key#4, $partitionby.$partitionbycol3#5, $partitionby.$partitionbycol4#6]
            |   +-expr_list=
            |   | +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | +-Key#4 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | +-$partitionbycol3#5 :=
            |   | | +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   | |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   | |   +-Literal(type=INT64, value=1)
            |   | +-$partitionbycol4#6 :=
            |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   |     +-Literal(type=INT64, value=1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-partition_by=
            |   | +-WindowPartitioning
            |   |   +-partition_by_list=
            |   |     +-ColumnRef(type=INT64, column=$partitionby.Key#3)
            |   |     +-ColumnRef(type=INT64, column=$partitionby.Key#4)
            |   |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol3#5)
            |   |     +-ColumnRef(type=INT64, column=$partitionby.$partitionbycol4#6)
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#10 :=
            |     | +-AggregateFunctionCall(GoogleSQL:min(STRING) -> STRING)
            |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |     +-$agg2#12 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(STRING) -> STRING)
            |         +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#7
            +-match_row_number_column=$match_recognize.$match_row_number#8
            +-classifier_column=$match_recognize.$classifier#9
==

# Correct name resolution on partitioning columns
SELECT * FROM KeyValue MATCH_RECOGNIZE(
    PARTITION BY Key
    ORDER BY value
    MEASURES max(length(value)) + Key AS m
    PATTERN ( a )
    DEFINE
      a AS true
  )
--
QueryStmt
+-output_column_list=
| +-$partitionby.Key#3 AS Key [INT64]
| +-$match_recognize.m#8 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$partitionby.Key#3, $match_recognize.m#8]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$partitionby.Key#3, $match_recognize.m#8]
        +-expr_list=
        | +-m#8 :=
        |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#7)
        |     +-ColumnRef(type=INT64, column=$partitionby.Key#3)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$partitionby.Key#3, $aggregate.$agg1#7]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.Key#3]
            |   +-expr_list=
            |   | +-Key#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |   +-input_scan=
            |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-partition_by=
            |   | +-WindowPartitioning
            |   |   +-partition_by_list=
            |   |     +-ColumnRef(type=INT64, column=$partitionby.Key#3)
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="a"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=true)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#7 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
==

# AFTER MATCH SKIP TO PAST LAST ROW
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max(length(value)) AS m
  {{|AFTER MATCH SKIP PAST LAST ROW|AFTER MATCH SKIP TO NEXT ROW}}
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
)
--
ALTERNATION GROUPS:
    <empty>
    AFTER MATCH SKIP PAST LAST ROW
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
--
ALTERNATION GROUP: AFTER MATCH SKIP TO NEXT ROW
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=NEXT_ROW
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# With the use_longest_match option
[allow_undeclared_parameters]
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS ({{use_LonGeST_match|`use_LonGeST_match`}} = {{true|false|@test_param_bool|@p}})
)
--
ALTERNATION GROUPS:
    use_LonGeST_match,true
    `use_LonGeST_match`,true
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-option_list=
            | +-use_LonGeST_match := Literal(type=BOOL, value=true)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
[UNDECLARED_PARAMETERS]
--
ALTERNATION GROUPS:
    use_LonGeST_match,false
    `use_LonGeST_match`,false
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-option_list=
            | +-use_LonGeST_match := Literal(type=BOOL, value=false)
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
[UNDECLARED_PARAMETERS]
--
ALTERNATION GROUPS:
    use_LonGeST_match,@test_param_bool
    `use_LonGeST_match`,@test_param_bool
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-option_list=
            | +-use_LonGeST_match := Parameter(type=BOOL, name="test_param_bool")
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
[UNDECLARED_PARAMETERS]
--
ALTERNATION GROUP: use_LonGeST_match,@p
--
ERROR: MATCH_RECOGNIZE option `use_LonGeST_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_LonGeST_match = @p)
          ^
--
ALTERNATION GROUP: `use_LonGeST_match`,@p
--
ERROR: MATCH_RECOGNIZE option `use_LonGeST_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (`use_LonGeST_match` = @p)
          ^
==

# Empty options list is a NOOP
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS ()
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Duplicate option
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS (use_longest_match = true, use_longest_match = true)
)
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` cannot be specified multiple times [at 7:11]
  OPTIONS (use_longest_match = true, use_longest_match = true)
          ^
==

# Invalid values
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS (use_longest_match = {{false AND true|NULL|UNKNOWN|CAST(NULL AS BOOL)|CAST(UNKNOWN AS BOOL)|"foo"|1+1|true IS NOT NULL|@test_param_int64}})
)
--
ALTERNATION GROUP: false AND true
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean literal or parameter [at 7:11]
  OPTIONS (use_longest_match = false AND true)
          ^
--
ALTERNATION GROUP: NULL
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_longest_match = NULL)
          ^
--
ALTERNATION GROUP: UNKNOWN
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found STRING [at 7:11]
  OPTIONS (use_longest_match = UNKNOWN)
          ^
--
ALTERNATION GROUP: CAST(NULL AS BOOL)
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` cannot be NULL [at 7:11]
  OPTIONS (use_longest_match = CAST(NULL AS BOOL))
          ^
--
ALTERNATION GROUP: CAST(UNKNOWN AS BOOL)
--
ERROR: Unrecognized name: UNKNOWN [at 7:37]
  OPTIONS (use_longest_match = CAST(UNKNOWN AS BOOL))
                                    ^
--
ALTERNATION GROUP: "foo"
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found STRING [at 7:11]
  OPTIONS (use_longest_match = "foo")
          ^
--
ALTERNATION GROUP: 1+1
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_longest_match = 1+1)
          ^
--
ALTERNATION GROUP: true IS NOT NULL
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean literal or parameter [at 7:11]
  OPTIONS (use_longest_match = true IS NOT NULL)
          ^
--
ALTERNATION GROUP: @test_param_int64
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean value, but found INT64 [at 7:11]
  OPTIONS (use_longest_match = @test_param_int64)
          ^
==

# Invalid option names & qualifiers
[allow_undeclared_parameters]
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS ({{@test_param_string|@p|?|blah|x.use_longest_match}} = true)
)
--
ALTERNATION GROUP: @test_param_string
--
ERROR: Syntax error: Expected ")" but got "@" [at 7:12]
  OPTIONS (@test_param_string = true)
           ^
--
ALTERNATION GROUP: @p
--
ERROR: Syntax error: Expected ")" but got "@" [at 7:12]
  OPTIONS (@p = true)
           ^
--
ALTERNATION GROUP: ?
--
ERROR: Syntax error: Expected ")" but got "?" [at 7:12]
  OPTIONS (? = true)
           ^
--
ALTERNATION GROUP: blah
--
ERROR: Unrecognized MATCH_RECOGNIZE option `blah` [at 7:11]
  OPTIONS (blah = true)
          ^
--
ALTERNATION GROUP: x.use_longest_match
--
ERROR: Syntax error: Expected "=" but got "." [at 7:13]
  OPTIONS (x.use_longest_match = true)
            ^
==

# Anchors, which can be quantified if parenthesized
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (`^` ^ (^`^`)+ | ($)+? $ `$`)
  DEFINE
    `^` AS length(value) < 10,
    `$` AS length(value) > 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#7 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#7]
        +-expr_list=
        | +-m#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=[$aggregate.$agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="^"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="$"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=ALTERNATE
            |   +-operand_list=
            |     +-MatchRecognizePatternOperation
            |     | +-op_type=CONCAT
            |     | +-operand_list=
            |     |   +-MatchRecognizePatternVariableRef(name="^")
            |     |   +-MatchRecognizePatternAnchor(mode=START)
            |     |   +-MatchRecognizePatternQuantification
            |     |     +-operand=
            |     |     | +-MatchRecognizePatternOperation
            |     |     |   +-op_type=CONCAT
            |     |     |   +-operand_list=
            |     |     |     +-MatchRecognizePatternAnchor(mode=START)
            |     |     |     +-MatchRecognizePatternVariableRef(name="^")
            |     |     +-lower_bound=
            |     |     | +-Literal(type=INT64, value=1)
            |     |     +-is_reluctant=FALSE
            |     +-MatchRecognizePatternOperation
            |       +-op_type=CONCAT
            |       +-operand_list=
            |         +-MatchRecognizePatternQuantification
            |         | +-operand=
            |         | | +-MatchRecognizePatternAnchor(mode=END)
            |         | +-lower_bound=
            |         | | +-Literal(type=INT64, value=1)
            |         | +-is_reluctant=TRUE
            |         +-MatchRecognizePatternAnchor(mode=END)
            |         +-MatchRecognizePatternVariableRef(name="$")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |         +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |           +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Inside a function definition. Regression test for b/374847219.
# Note that this is a UDF, not a TVF, so the SELECT is a subquery.
CREATE TEMP FUNCTION tvf(fn_arg INT64) RETURNS INT64 AS (
  (
    SELECT max(m) FROM KeyValue t MATCH_RECOGNIZE(
      PARTITION BY fn_arg
      ORDER BY length(value) / fn_arg
      MEASURES
        min(length(value) + key + fn_arg) - fn_arg AS m
      PATTERN (a)
      DEFINE
        A AS length(value) < 10
    )
  )
)
--
CreateFunctionStmt
+-name_path=tvf
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=INT64
+-argument_name_list=[fn_arg]
+-signature=(INT64 fn_arg) -> INT64
+-language="SQL"
+-code="(\n    SELECT max(m) FROM KeyValue t MATCH_RECOGNIZE(\n      PARTITION BY fn_arg\n      ORDER BY length(value) / fn_arg\n      MEASURES\n        min(length(value) + key + fn_arg) - fn_arg AS m\n      PATTERN (a)\n      DEFINE\n        A AS length(value) < 10\n    )\n  )"
+-function_expression=
  +-SubqueryExpr
    +-type=INT64
    +-subquery_type=SCALAR
    +-subquery=
      +-ProjectScan
        +-column_list=[$aggregate.$agg1#10]
        +-input_scan=
          +-AggregateScan
            +-column_list=[$aggregate.$agg1#10]
            +-input_scan=
            | +-ProjectScan
            |   +-column_list=[$partitionby.fn_arg#3, $match_recognize.m#9]
            |   +-expr_list=
            |   | +-m#9 :=
            |   |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
            |   |     +-ColumnRef(type=INT64, column=$aggregate.$agg1#8)
            |   |     +-ArgumentRef(type=INT64, name="fn_arg")
            |   +-input_scan=
            |     +-MatchRecognizeScan
            |       +-column_list=[$partitionby.fn_arg#3, $aggregate.$agg1#8]
            |       +-input_scan=
            |       | +-ProjectScan
            |       |   +-column_list=[KeyValue.Key#1, KeyValue.Value#2, $partitionby.fn_arg#3, $orderby.$orderbycol1#4]
            |       |   +-expr_list=
            |       |   | +-fn_arg#3 := ArgumentRef(type=INT64, name="fn_arg")
            |       |   | +-$orderbycol1#4 :=
            |       |   |   +-FunctionCall(GoogleSQL:$divide(DOUBLE, DOUBLE) -> DOUBLE)
            |       |   |     +-Cast(INT64 -> DOUBLE)
            |       |   |     | +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       |   |     |   +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       |   |     +-Cast(INT64 -> DOUBLE)
            |       |   |       +-ArgumentRef(type=INT64, name="fn_arg")
            |       |   +-input_scan=
            |       |     +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1], alias="t")
            |       +-analytic_function_group_list=
            |       | +-AnalyticFunctionGroup
            |       |   +-partition_by=
            |       |   | +-WindowPartitioning
            |       |   |   +-partition_by_list=
            |       |   |     +-ColumnRef(type=INT64, column=$partitionby.fn_arg#3)
            |       |   +-order_by=
            |       |     +-WindowOrdering
            |       |       +-order_by_item_list=
            |       |         +-OrderByItem
            |       |           +-column_ref=
            |       |             +-ColumnRef(type=DOUBLE, column=$orderby.$orderbycol1#4)
            |       +-pattern_variable_definition_list=
            |       | +-MatchRecognizeVariableDefinition
            |       |   +-name="A"
            |       |   +-predicate=
            |       |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |       |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       |       +-Literal(type=INT64, value=10)
            |       +-pattern=
            |       | +-MatchRecognizePatternVariableRef(name="A")
            |       +-after_match_skip_mode=END_OF_MATCH
            |       +-measure_group_list=
            |       | +-MeasureGroup
            |       |   +-aggregate_list=
            |       |     +-$agg1#8 :=
            |       |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |       |         +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |       |           +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |       |           | +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       |           | | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       |           | +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       |           +-ColumnRef(type=INT64, column=$partitionby.fn_arg#3)
            |       +-match_number_column=$match_recognize.$match_number#5
            |       +-match_row_number_column=$match_recognize.$match_row_number#6
            |       +-classifier_column=$match_recognize.$classifier#7
            +-aggregate_list=
              +-$agg1#10 :=
                +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
                  +-ColumnRef(type=INT64, column=$match_recognize.m#9)
==

# Grouping constants, catalog constants, correlated references, etc are OK since
# they're the same for all rows.
CREATE TEMP FUNCTION tvf(fn_arg INT64) RETURNS ARRAY<INT64> AS (
  (WITH outer_tbl AS (SELECT [1, 2] AS arr, 1 AS a)
   SELECT
      ARRAY_TRANSFORM([1, 2], lambda_arg ->
       (SELECT max(m) from KeyValue t MATCH_RECOGNIZE(
        ORDER BY length(value)
        MEASURES
          min(length(a.value) + lambda_arg + outer_tbl.a + fn_arg + TestConstantInt64) AS m
        PATTERN (a)
        DEFINE
          A AS length(value) < 10
       )
      )
     )
  FROM outer_tbl
  )
)
--
CreateFunctionStmt
+-name_path=tvf
+-create_scope=CREATE_TEMP
+-has_explicit_return_type=TRUE
+-return_type=ARRAY<INT64>
+-argument_name_list=[fn_arg]
+-signature=(INT64 fn_arg) -> ARRAY<INT64>
+-language="SQL"
+-code="(WITH outer_tbl AS (SELECT [1, 2] AS arr, 1 AS a)\n   SELECT\n      ARRAY_TRANSFORM([1, 2], lambda_arg ->\n       (SELECT max(m) from KeyValue t MATCH_RECOGNIZE(\n        ORDER BY length(value)\n        MEASURES\n          min(length(a.value) + lambda_arg + outer_tbl.a + fn_arg + TestConstantInt64) AS m\n        PATTERN (a)\n        DEFINE\n          A AS length(value) < 10\n       )\n      )\n     )\n  FROM outer_tbl\n  )"
+-function_expression=
  +-SubqueryExpr
    +-type=ARRAY<INT64>
    +-subquery_type=SCALAR
    +-subquery=
      +-WithScan
        +-column_list=[$expr_subquery.$col1#15]
        +-with_entry_list=
        | +-WithEntry
        |   +-with_query_name="outer_tbl"
        |   +-with_subquery=
        |     +-ProjectScan
        |       +-column_list=outer_tbl.[arr#1, a#2]
        |       +-expr_list=
        |       | +-arr#1 := Literal(type=ARRAY<INT64>, value=[1, 2])
        |       | +-a#2 := Literal(type=INT64, value=1)
        |       +-input_scan=
        |         +-SingleRowScan
        +-query=
          +-ProjectScan
            +-column_list=[$expr_subquery.$col1#15]
            +-expr_list=
            | +-$col1#15 :=
            |   +-FunctionCall(GoogleSQL:array_transform(ARRAY<INT64> array_to_transform, FUNCTION<INT64->INT64> transformation) -> ARRAY<INT64>)
            |     +-FunctionArgument
            |     | +-expr=
            |     |   +-Literal(type=ARRAY<INT64>, value=[1, 2])
            |     +-FunctionArgument
            |       +-inline_lambda=
            |         +-InlineLambda
            |           +-argument_list=[$lambda_arg.lambda_arg#5]
            |           +-parameter_list=
            |           | +-ColumnRef(type=INT64, column=outer_tbl.a#4)
            |           +-body=
            |             +-SubqueryExpr
            |               +-type=INT64
            |               +-subquery_type=SCALAR
            |               +-parameter_list=
            |               | +-ColumnRef(type=INT64, column=outer_tbl.a#4, is_correlated=TRUE)
            |               | +-ColumnRef(type=INT64, column=$lambda_arg.lambda_arg#5)
            |               +-subquery=
            |                 +-ProjectScan
            |                   +-column_list=[$aggregate.$agg1#14]
            |                   +-input_scan=
            |                     +-AggregateScan
            |                       +-column_list=[$aggregate.$agg1#14]
            |                       +-input_scan=
            |                       | +-ProjectScan
            |                       |   +-column_list=[$match_recognize.m#13]
            |                       |   +-expr_list=
            |                       |   | +-m#13 := ColumnRef(type=INT64, column=$aggregate.$agg1#12)
            |                       |   +-input_scan=
            |                       |     +-MatchRecognizeScan
            |                       |       +-column_list=[$aggregate.$agg1#12]
            |                       |       +-input_scan=
            |                       |       | +-ProjectScan
            |                       |       |   +-column_list=[KeyValue.Value#7, $orderby.$orderbycol1#8]
            |                       |       |   +-expr_list=
            |                       |       |   | +-$orderbycol1#8 :=
            |                       |       |   |   +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |                       |       |   |     +-ColumnRef(type=STRING, column=KeyValue.Value#7)
            |                       |       |   +-input_scan=
            |                       |       |     +-TableScan(column_list=[KeyValue.Value#7], table=KeyValue, column_index_list=[1], alias="t")
            |                       |       +-analytic_function_group_list=
            |                       |       | +-AnalyticFunctionGroup
            |                       |       |   +-order_by=
            |                       |       |     +-WindowOrdering
            |                       |       |       +-order_by_item_list=
            |                       |       |         +-OrderByItem
            |                       |       |           +-column_ref=
            |                       |       |             +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#8)
            |                       |       +-pattern_variable_definition_list=
            |                       |       | +-MatchRecognizeVariableDefinition
            |                       |       |   +-name="A"
            |                       |       |   +-predicate=
            |                       |       |     +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            |                       |       |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |                       |       |       | +-ColumnRef(type=STRING, column=KeyValue.Value#7)
            |                       |       |       +-Literal(type=INT64, value=10)
            |                       |       +-pattern=
            |                       |       | +-MatchRecognizePatternVariableRef(name="A")
            |                       |       +-after_match_skip_mode=END_OF_MATCH
            |                       |       +-measure_group_list=
            |                       |       | +-MeasureGroup
            |                       |       |   +-pattern_variable_ref=
            |                       |       |   | +-MatchRecognizePatternVariableRef(name="A")
            |                       |       |   +-aggregate_list=
            |                       |       |     +-$agg1#12 :=
            |                       |       |       +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |                       |       |         +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |                       |       |           +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |                       |       |           | +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |                       |       |           | | +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            |                       |       |           | | | +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |                       |       |           | | | | +-ColumnRef(type=STRING, column=KeyValue.Value#7)
            |                       |       |           | | | +-ColumnRef(type=INT64, column=$lambda_arg.lambda_arg#5, is_correlated=TRUE)
            |                       |       |           | | +-ColumnRef(type=INT64, column=outer_tbl.a#4, is_correlated=TRUE)
            |                       |       |           | +-ArgumentRef(type=INT64, name="fn_arg")
            |                       |       |           +-Constant(TestConstantInt64, type=INT64, value=1)
            |                       |       +-match_number_column=$match_recognize.$match_number#9
            |                       |       +-match_row_number_column=$match_recognize.$match_row_number#10
            |                       |       +-classifier_column=$match_recognize.$classifier#11
            |                       +-aggregate_list=
            |                         +-$agg1#14 :=
            |                           +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |                             +-ColumnRef(type=INT64, column=$match_recognize.m#13)
            +-input_scan=
              +-WithRefScan(column_list=outer_tbl.[arr#3, a#4], with_query_name="outer_tbl")
==

SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(a.key) AS min_a_z, max(a.key) AS max_a_z, min(b.key) AS min_b_z, max(b.key) AS max_b_z,
           max(a.key - length(a.value)) AS multiple_as, max(b.key - length(b.value)) AS multiple_bs,
           avg(a.key) - avg(b.key) + avg(key) AS mixed_aggs
  PATTERN ( a* b* )
  DEFINE
    a AS length(value) < 10,
    b AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.min_a_z#7 AS min_a_z [INT64]
| +-$match_recognize.max_a_z#9 AS max_a_z [INT64]
| +-$match_recognize.min_b_z#11 AS min_b_z [INT64]
| +-$match_recognize.max_b_z#13 AS max_b_z [INT64]
| +-$match_recognize.multiple_as#15 AS multiple_as [INT64]
| +-$match_recognize.multiple_bs#17 AS multiple_bs [INT64]
| +-$match_recognize.mixed_aggs#21 AS mixed_aggs [DOUBLE]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[min_a_z#7, max_a_z#9, min_b_z#11, max_b_z#13, multiple_as#15, multiple_bs#17, mixed_aggs#21]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[min_a_z#7, max_a_z#9, min_b_z#11, max_b_z#13, multiple_as#15, multiple_bs#17, mixed_aggs#21]
        +-expr_list=
        | +-min_a_z#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-max_a_z#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        | +-min_b_z#11 := ColumnRef(type=INT64, column=$aggregate.$agg3#10)
        | +-max_b_z#13 := ColumnRef(type=INT64, column=$aggregate.$agg4#12)
        | +-multiple_as#15 := ColumnRef(type=INT64, column=$aggregate.$agg5#14)
        | +-multiple_bs#17 := ColumnRef(type=INT64, column=$aggregate.$agg6#16)
        | +-mixed_aggs#21 :=
        |   +-FunctionCall(GoogleSQL:$add(DOUBLE, DOUBLE) -> DOUBLE)
        |     +-FunctionCall(GoogleSQL:$subtract(DOUBLE, DOUBLE) -> DOUBLE)
        |     | +-ColumnRef(type=DOUBLE, column=$aggregate.$agg7#18)
        |     | +-ColumnRef(type=DOUBLE, column=$aggregate.$agg8#19)
        |     +-ColumnRef(type=DOUBLE, column=$aggregate.$agg9#20)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg9#20, $agg1#6, $agg2#8, $agg5#14, $agg7#18, $agg3#10, $agg4#12, $agg6#16, $agg8#19]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="a"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="b"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternQuantification
            |     | +-operand=
            |     | | +-MatchRecognizePatternVariableRef(name="a")
            |     | +-lower_bound=
            |     | | +-Literal(type=INT64, value=0)
            |     | +-is_reluctant=FALSE
            |     +-MatchRecognizePatternQuantification
            |       +-operand=
            |       | +-MatchRecognizePatternVariableRef(name="b")
            |       +-lower_bound=
            |       | +-Literal(type=INT64, value=0)
            |       +-is_reluctant=FALSE
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg9#20 :=
            | |     +-AggregateFunctionCall(GoogleSQL:avg(INT64) -> DOUBLE)
            | |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | +-MeasureGroup
            | | +-pattern_variable_ref=
            | | | +-MatchRecognizePatternVariableRef(name="a")
            | | +-aggregate_list=
            | |   +-$agg1#6 :=
            | |   | +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            | |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | |   +-$agg2#8 :=
            | |   | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            | |   |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | |   +-$agg5#14 :=
            | |   | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            | |   |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
            | |   |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | |   |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |   |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |   +-$agg7#18 :=
            | |     +-AggregateFunctionCall(GoogleSQL:avg(INT64) -> DOUBLE)
            | |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="b")
            |   +-aggregate_list=
            |     +-$agg3#10 :=
            |     | +-AggregateFunctionCall(GoogleSQL:min(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg4#12 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg6#16 :=
            |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
            |     |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
            |     |     +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |     |       +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |     +-$agg8#19 :=
            |       +-AggregateFunctionCall(GoogleSQL:avg(INT64) -> DOUBLE)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Subqueries in the MEASURES clause cannot see the pattern variables.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max((SELECT max(a.value) FROM UNNEST([1,2]) AS t)) AS mx
  PATTERN (a)
  DEFINE a AS true
)
--
ERROR: Correlated access to MATCH_RECOGNIZE columns in the MEASURES clause is not allowed [at 3:28]
  MEASURES max((SELECT max(a.value) FROM UNNEST([1,2]) AS t)) AS mx
                           ^
==

# Nested MR cannot reference a pattern var from an outer MR.
# But they can be shadowed by names in the inner MR, e.g. note the alternation
# where `a` is shadowed by the inner MR's input range variable.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max(
              (SELECT v1 || v2 FROM KeyValue {{|a}} MATCH_RECOGNIZE(
                  ORDER BY key
                  MEASURES min({{a|a.value}}) AS v1, min(b.value) AS v2
                  PATTERN (b)
                  DEFINE b AS true
                )
              )
          ) AS mx
  PATTERN (a b)
  DEFINE a AS length(value) < 10,
         b AS length(value) >= 10
)
--
ALTERNATION GROUPS:
    a
    a.value
--
ERROR: MATCH_RECOGNIZE clause cannot be nested inside another MATCH_RECOGNIZE clause [at 4:47]
              (SELECT v1 || v2 FROM KeyValue  MATCH_RECOGNIZE(
                                              ^
--
ALTERNATION GROUPS:
    a,a
    a,a.value
--
ERROR: MATCH_RECOGNIZE clause cannot be nested inside another MATCH_RECOGNIZE clause [at 4:48]
              (SELECT v1 || v2 FROM KeyValue a MATCH_RECOGNIZE(
                                               ^
==

# Pattern variable references cannot be used as value tables
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES max(a) AS m
  PATTERN ( a+ )
  DEFINE
    a AS length(value) < 10
)
--
ERROR: Pattern variable a cannot be used as a value table [at 3:16]
  MEASURES max(a) AS m
               ^
==

# Unaggregated var
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES {{a|a.value}} AS m
  PATTERN ( a b* )
  DEFINE
    a AS length(value) < 10,
    b AS length(value) >= 10
)
--
ALTERNATION GROUP: a
--
ERROR: Cannot access columns through pattern variables. [at 3:12]
  MEASURES a AS m
           ^
--
ALTERNATION GROUP: a.value
--
ERROR: Cannot access columns through pattern variables. [at 3:12]
  MEASURES a.value AS m
           ^
==

# Pattern variables take precedence over struct qualifiers.
WITH t AS (SELECT STRUCT<b INT64>(1) AS a, 2 AS b)
SELECT * FROM t MATCH_RECOGNIZE (
  ORDER BY a.b, b
  MEASURES max(a.b - a.a.b) AS m1, any_value(a.a) AS m2
  PATTERN (a)
  DEFINE
    A AS true
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m1#10 AS m1 [INT64]
| +-$match_recognize.m2#12 AS m2 [STRUCT<b INT64>]
+-query=
  +-WithScan
    +-column_list=$match_recognize.[m1#10, m2#12]
    +-with_entry_list=
    | +-WithEntry
    |   +-with_query_name="t"
    |   +-with_subquery=
    |     +-ProjectScan
    |       +-column_list=t.[a#1, b#2]
    |       +-expr_list=
    |       | +-a#1 := Literal(type=STRUCT<b INT64>, value={b:1}, has_explicit_type=TRUE)
    |       | +-b#2 := Literal(type=INT64, value=2)
    |       +-input_scan=
    |         +-SingleRowScan
    +-query=
      +-ProjectScan
        +-column_list=$match_recognize.[m1#10, m2#12]
        +-input_scan=
          +-ProjectScan
            +-column_list=$match_recognize.[m1#10, m2#12]
            +-expr_list=
            | +-m1#10 := ColumnRef(type=INT64, column=$aggregate.$agg1#9)
            | +-m2#12 := ColumnRef(type=STRUCT<b INT64>, column=$aggregate.$agg2#11)
            +-input_scan=
              +-MatchRecognizeScan
                +-column_list=$aggregate.[$agg1#9, $agg2#11]
                +-input_scan=
                | +-ProjectScan
                |   +-column_list=[t.a#3, t.b#4, $orderby.b#5]
                |   +-expr_list=
                |   | +-b#5 :=
                |   |   +-GetStructField
                |   |     +-type=INT64
                |   |     +-expr=
                |   |     | +-ColumnRef(type=STRUCT<b INT64>, column=t.a#3)
                |   |     +-field_idx=0
                |   +-input_scan=
                |     +-WithRefScan(column_list=t.[a#3, b#4], with_query_name="t")
                +-analytic_function_group_list=
                | +-AnalyticFunctionGroup
                |   +-order_by=
                |     +-WindowOrdering
                |       +-order_by_item_list=
                |         +-OrderByItem
                |         | +-column_ref=
                |         |   +-ColumnRef(type=INT64, column=$orderby.b#5)
                |         +-OrderByItem
                |           +-column_ref=
                |             +-ColumnRef(type=INT64, column=t.b#4)
                +-pattern_variable_definition_list=
                | +-MatchRecognizeVariableDefinition
                |   +-name="A"
                |   +-predicate=
                |     +-Literal(type=BOOL, value=true)
                +-pattern=
                | +-MatchRecognizePatternVariableRef(name="A")
                +-after_match_skip_mode=END_OF_MATCH
                +-measure_group_list=
                | +-MeasureGroup
                |   +-pattern_variable_ref=
                |   | +-MatchRecognizePatternVariableRef(name="A")
                |   +-aggregate_list=
                |     +-$agg1#9 :=
                |     | +-AggregateFunctionCall(GoogleSQL:max(INT64) -> INT64)
                |     |   +-FunctionCall(GoogleSQL:$subtract(INT64, INT64) -> INT64)
                |     |     +-ColumnRef(type=INT64, column=t.b#4)
                |     |     +-GetStructField
                |     |       +-type=INT64
                |     |       +-expr=
                |     |       | +-ColumnRef(type=STRUCT<b INT64>, column=t.a#3)
                |     |       +-field_idx=0
                |     +-$agg2#11 :=
                |       +-AggregateFunctionCall(GoogleSQL:any_value(STRUCT<b INT64>) -> STRUCT<b INT64>)
                |         +-ColumnRef(type=STRUCT<b INT64>, column=t.a#3)
                +-match_number_column=$match_recognize.$match_number#6
                +-match_row_number_column=$match_recognize.$match_row_number#7
                +-classifier_column=$match_recognize.$classifier#8
==

# Error on aggs mixing different ranges
# Note that `m1` has one valid combination to allow the error in the second
# alternation where the full input range appears before the pattern variable to
# also show up.
SELECT * FROM KeyValue t MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(a.key - {{|t.|b.|a.}}key) AS m1,
           min({{t.|}}key - a.key) AS m2
  PATTERN (a b)
  DEFINE
    a AS true,
    b AS true
)
--
ALTERNATION GROUPS:
    t.
    <empty>
--
ERROR: Column access ranges over all input rows in an expression that already ranges over a pattern variable a [at 3:24]
  MEASURES min(a.key - key) AS m1,
                       ^
--
ALTERNATION GROUPS:
    t.,t.
    t.,
--
ERROR: Column access ranges over all input rows in an expression that already ranges over a pattern variable a [at 3:24]
  MEASURES min(a.key - t.key) AS m1,
                       ^
--
ALTERNATION GROUPS:
    b.,t.
    b.,
--
ERROR: Column access ranges over pattern variable b in an expression that already ranges over a pattern variable a [at 3:24]
  MEASURES min(a.key - b.key) AS m1,
                       ^
--
ALTERNATION GROUP: a.,t.
--
ERROR: Column access ranges over pattern variable a in an expression that already ranges over a all input rows [at 4:24]
           min(t.key - a.key) AS m2
                       ^
--
ALTERNATION GROUP: a.,
--
ERROR: Column access ranges over pattern variable a in an expression that already ranges over a all input rows [at 4:22]
           min(key - a.key) AS m2
                     ^
==

# Coercing NULL in the DEFINE clause's predicates.
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES 1 AS m
  PATTERN (a)
  DEFINE
    A AS NULL
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#6 AS m [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#6]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.m#6]
        +-expr_list=
        | +-m#6 := Literal(type=INT64, value=1)
        +-input_scan=
          +-MatchRecognizeScan
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="A"
            |   +-predicate=
            |     +-Literal(type=BOOL, value=NULL)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="A")
            +-after_match_skip_mode=END_OF_MATCH
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Test case for the GROUPING() function. PARTITION BY operates like grouping but
# we do not have grouping sets.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  PARTITION BY Key
  ORDER BY Key
  MEASURES GROUPING(key) AS m
  PATTERN (a)
  DEFINE
    a AS true
)
--
ERROR: GROUPING must have an argument that exists within the group-by expression list. [at 4:12]
  MEASURES GROUPING(key) AS m
           ^
==

# Regression test for b/379925625
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  PARTITION BY with(x AS key, x+1), key
  ORDER BY with(y AS key, y+1)
  MEASURES max(with(p AS length(value) + key, p+key)) + key AS m1,
           max(with(q AS length(a.value) + a.key,
               {{a.|}}q + key))
               + key AS m2,
           with(m1 AS min(length({{a.|}}value)), m1) AS m3
  PATTERN (a)
  DEFINE
    a AS with(x AS length(value), x > 10)
)
--
ALTERNATION GROUPS:
    a.,a.
    a.,
--
ERROR: Name q not found inside a [at 6:18]
               a.q + key))
                 ^
--
ALTERNATION GROUPS:
    a.
    <empty>
--
ERROR: Column access ranges over all input rows in an expression that already ranges over a pattern variable a [at 6:16]
               q + key))
               ^
==

# On a value table.
SELECT *
FROM TestExtraValueTable t
  MATCH_RECOGNIZE(
    ORDER BY int32_val2 + 1 DESC
    MEASURES any_value({{a.int32_val2|a|t}}) AS m
    AFTER MATCH SKIP TO NEXT ROW
    PATTERN (a)
    DEFINE
      a AS true
    OPTIONS(use_longest_match=true)
)
WHERE m.int32_val1 + m.int32_val2 > 10
--
ALTERNATION GROUP: a.int32_val2
--
ERROR: Name a.int32_val2 is a value table field, but a column was expected [at 5:24]
    MEASURES any_value(a.int32_val2) AS m
                       ^
--
ALTERNATION GROUP: a
--
ERROR: Pattern variable a cannot be used as a value table [at 5:24]
    MEASURES any_value(a) AS m
                       ^
--
ALTERNATION GROUP: t
--
QueryStmt
+-output_column_list=
| +-$match_recognize.m#9 AS m [PROTO<googlesql_test.TestExtraPB>]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.m#9]
    +-input_scan=
      +-FilterScan
        +-column_list=[$match_recognize.m#9]
        +-input_scan=
        | +-ProjectScan
        |   +-column_list=[$match_recognize.m#9]
        |   +-expr_list=
        |   | +-m#9 := ColumnRef(type=PROTO<googlesql_test.TestExtraPB>, column=$aggregate.$agg1#8)
        |   +-input_scan=
        |     +-MatchRecognizeScan
        |       +-column_list=[$aggregate.$agg1#8]
        |       +-input_scan=
        |       | +-ProjectScan
        |       |   +-column_list=[TestExtraValueTable.value#1, $orderby.$orderbycol1#4]
        |       |   +-expr_list=
        |       |   | +-$orderbycol1#4 :=
        |       |   |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        |       |   |     +-Cast(INT32 -> INT64)
        |       |   |     | +-GetProtoField
        |       |   |     |   +-type=INT32
        |       |   |     |   +-expr=
        |       |   |     |   | +-ColumnRef(type=PROTO<googlesql_test.TestExtraPB>, column=TestExtraValueTable.value#1)
        |       |   |     |   +-field_descriptor=int32_val2
        |       |   |     |   +-default_value=0
        |       |   |     +-Literal(type=INT64, value=1)
        |       |   +-input_scan=
        |       |     +-TableScan(column_list=[TestExtraValueTable.value#1], table=TestExtraValueTable, column_index_list=[0], alias="t")
        |       +-option_list=
        |       | +-use_longest_match := Literal(type=BOOL, value=true)
        |       +-analytic_function_group_list=
        |       | +-AnalyticFunctionGroup
        |       |   +-order_by=
        |       |     +-WindowOrdering
        |       |       +-order_by_item_list=
        |       |         +-OrderByItem
        |       |           +-column_ref=
        |       |           | +-ColumnRef(type=INT64, column=$orderby.$orderbycol1#4)
        |       |           +-is_descending=TRUE
        |       +-pattern_variable_definition_list=
        |       | +-MatchRecognizeVariableDefinition
        |       |   +-name="a"
        |       |   +-predicate=
        |       |     +-Literal(type=BOOL, value=true)
        |       +-pattern=
        |       | +-MatchRecognizePatternVariableRef(name="a")
        |       +-after_match_skip_mode=NEXT_ROW
        |       +-measure_group_list=
        |       | +-MeasureGroup
        |       |   +-aggregate_list=
        |       |     +-$agg1#8 :=
        |       |       +-AggregateFunctionCall(GoogleSQL:any_value(PROTO<googlesql_test.TestExtraPB>) -> PROTO<googlesql_test.TestExtraPB>)
        |       |         +-ColumnRef(type=PROTO<googlesql_test.TestExtraPB>, column=TestExtraValueTable.value#1)
        |       +-match_number_column=$match_recognize.$match_number#5
        |       +-match_row_number_column=$match_recognize.$match_row_number#6
        |       +-classifier_column=$match_recognize.$classifier#7
        +-filter_expr=
          +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
            +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
            | +-Cast(INT32 -> INT64)
            | | +-GetProtoField
            | |   +-type=INT32
            | |   +-expr=
            | |   | +-ColumnRef(type=PROTO<googlesql_test.TestExtraPB>, column=$match_recognize.m#9)
            | |   +-field_descriptor=int32_val1
            | |   +-default_value=0
            | +-Cast(INT32 -> INT64)
            |   +-GetProtoField
            |     +-type=INT32
            |     +-expr=
            |     | +-ColumnRef(type=PROTO<googlesql_test.TestExtraPB>, column=$match_recognize.m#9)
            |     +-field_descriptor=int32_val2
            |     +-default_value=0
            +-Literal(type=INT64, value=10)
==

# System variable as quantifier bound is not allowed
select * from KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES min(value) AS x
  PATTERN ( a{1, @@int64_system_variable})
  DEFINE
    A AS length(value) < 10
)
--
ERROR: MATCH_RECOGNIZE quantifier bound expects an integer literal or parameter [at 4:18]
  PATTERN ( a{1, @@int64_system_variable})
                 ^
==

# System variable as longest-match-mode option is not allowed
SELECT * FROM KeyValue MATCH_RECOGNIZE (
  ORDER BY key
  MEASURES max(length(value)) AS m
  PATTERN (a a)
  DEFINE
    A AS length(value) < 10
  OPTIONS (use_longest_match = @@bool_system_variable)
)
--
ERROR: MATCH_RECOGNIZE option `use_longest_match` requires a boolean literal or parameter [at 7:11]
  OPTIONS (use_longest_match = @@bool_system_variable)
          ^
==

SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    COUNT(*) AS cnt,
    SUM(b.key) AS sum_b_keys
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.cnt#7 AS cnt [INT64]
| +-$match_recognize.sum_b_keys#9 AS sum_b_keys [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[cnt#7, sum_b_keys#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[cnt#7, sum_b_keys#9]
        +-expr_list=
        | +-cnt#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-sum_b_keys#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#6, $agg2#8]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg1#6 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg2#8 :=
            |       +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Similar to above test case, but swaps the order of the aggregates so that
# COUNT(*) is last.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM(b.key) AS sum_b_keys,
    COUNT(*) AS cnt
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.sum_b_keys#7 AS sum_b_keys [INT64]
| +-$match_recognize.cnt#9 AS cnt [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[sum_b_keys#7, cnt#9]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[sum_b_keys#7, cnt#9]
        +-expr_list=
        | +-sum_b_keys#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-cnt#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg2#8, $agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg2#8 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Scalar expression that combines a symbol-qualified aggregate with a
# non-symbol-qualified aggregate that references no columns.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM(b.key) + COUNT(*) AS sum_plus_cnt_star,
    COUNT(*) + SUM(b.key) AS cnt_star_plus_sum,
    SUM(b.key) + COUNT(0) AS sum_plus_cnt_zero,
    COUNT(0) + SUM(b.key) AS cnt_zero_plus_sum
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.sum_plus_cnt_star#8 AS sum_plus_cnt_star [INT64]
| +-$match_recognize.cnt_star_plus_sum#11 AS cnt_star_plus_sum [INT64]
| +-$match_recognize.sum_plus_cnt_zero#14 AS sum_plus_cnt_zero [INT64]
| +-$match_recognize.cnt_zero_plus_sum#17 AS cnt_zero_plus_sum [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[sum_plus_cnt_star#8, cnt_star_plus_sum#11, sum_plus_cnt_zero#14, cnt_zero_plus_sum#17]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[sum_plus_cnt_star#8, cnt_star_plus_sum#11, sum_plus_cnt_zero#14, cnt_zero_plus_sum#17]
        +-expr_list=
        | +-sum_plus_cnt_star#8 :=
        | | +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg2#7)
        | +-cnt_star_plus_sum#11 :=
        | | +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg3#9)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg4#10)
        | +-sum_plus_cnt_zero#14 :=
        | | +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg5#12)
        | |   +-ColumnRef(type=INT64, column=$aggregate.$agg6#13)
        | +-cnt_zero_plus_sum#17 :=
        |   +-FunctionCall(GoogleSQL:$add(INT64, INT64) -> INT64)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg7#15)
        |     +-ColumnRef(type=INT64, column=$aggregate.$agg8#16)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg2#7, $agg3#9, $agg6#13, $agg7#15, $agg1#6, $agg4#10, $agg5#12, $agg8#16]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg2#7 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | |   +-$agg3#9 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | |   +-$agg6#13 :=
            | |   | +-AggregateFunctionCall(GoogleSQL:count(INT64) -> INT64)
            | |   |   +-Literal(type=INT64, value=0)
            | |   +-$agg7#15 :=
            | |     +-AggregateFunctionCall(GoogleSQL:count(INT64) -> INT64)
            | |       +-Literal(type=INT64, value=0)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |     | +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg4#10 :=
            |     | +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg5#12 :=
            |     | +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg8#16 :=
            |       +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Similar to above test case, but adds multiple aggregates with different
# symbol qualifiers.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM(b.key) AS sum_b_keys,
    COUNT(*) AS cnt,
    SUM(a.key) AS sum_b_keys
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.sum_b_keys#7 AS sum_b_keys [INT64]
| +-$match_recognize.cnt#9 AS cnt [INT64]
| +-$match_recognize.sum_b_keys#11 AS sum_b_keys [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[sum_b_keys#7, cnt#9, sum_b_keys#11]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[sum_b_keys#7, cnt#9, sum_b_keys#11]
        +-expr_list=
        | +-sum_b_keys#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-cnt#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        | +-sum_b_keys#11 := ColumnRef(type=INT64, column=$aggregate.$agg3#10)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg2#8, $agg3#10, $agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg2#8 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | +-MeasureGroup
            | | +-pattern_variable_ref=
            | | | +-MatchRecognizePatternVariableRef(name="A")
            | | +-aggregate_list=
            | |   +-$agg3#10 :=
            | |     +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            | |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Similar to above test case, but calls an aggregate function with a constant
# argument, rather than a zero-argument function.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM(b.key) AS sum_b_keys,
    SUM(0) AS sum_of_zero,
    SUM(a.key) AS sum_b_keys
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.sum_b_keys#7 AS sum_b_keys [INT64]
| +-$match_recognize.sum_of_zero#9 AS sum_of_zero [INT64]
| +-$match_recognize.sum_b_keys#11 AS sum_b_keys [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[sum_b_keys#7, sum_of_zero#9, sum_b_keys#11]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[sum_b_keys#7, sum_of_zero#9, sum_b_keys#11]
        +-expr_list=
        | +-sum_b_keys#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-sum_of_zero#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        | +-sum_b_keys#11 := ColumnRef(type=INT64, column=$aggregate.$agg3#10)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg2#8, $agg3#10, $agg1#6]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg2#8 :=
            | |     +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            | |       +-Literal(type=INT64, value=0)
            | +-MeasureGroup
            | | +-pattern_variable_ref=
            | | | +-MatchRecognizePatternVariableRef(name="A")
            | | +-aggregate_list=
            | |   +-$agg3#10 :=
            | |     +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            | |       +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |       +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Similar to above test case, but has multiple aggregators with the same
# qualifier
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM(b.key) AS sum_b_keys,
    COUNT(*) AS cnt,
    COUNT(b.key) AS count_b_keys
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.sum_b_keys#7 AS sum_b_keys [INT64]
| +-$match_recognize.cnt#9 AS cnt [INT64]
| +-$match_recognize.count_b_keys#11 AS count_b_keys [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[sum_b_keys#7, cnt#9, count_b_keys#11]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[sum_b_keys#7, cnt#9, count_b_keys#11]
        +-expr_list=
        | +-sum_b_keys#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-cnt#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        | +-count_b_keys#11 := ColumnRef(type=INT64, column=$aggregate.$agg3#10)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg2#8, $agg1#6, $agg3#10]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg2#8 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg1#6 :=
            |     | +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg3#10 :=
            |       +-AggregateFunctionCall(GoogleSQL:count(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Similar to above test case, but moves COUNT(*) first.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    COUNT(*) AS cnt,
    SUM(b.key) AS sum_b_keys,
    COUNT(b.key) AS count_b_keys
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.cnt#7 AS cnt [INT64]
| +-$match_recognize.sum_b_keys#9 AS sum_b_keys [INT64]
| +-$match_recognize.count_b_keys#11 AS count_b_keys [INT64]
+-query=
  +-ProjectScan
    +-column_list=$match_recognize.[cnt#7, sum_b_keys#9, count_b_keys#11]
    +-input_scan=
      +-ProjectScan
        +-column_list=$match_recognize.[cnt#7, sum_b_keys#9, count_b_keys#11]
        +-expr_list=
        | +-cnt#7 := ColumnRef(type=INT64, column=$aggregate.$agg1#6)
        | +-sum_b_keys#9 := ColumnRef(type=INT64, column=$aggregate.$agg2#8)
        | +-count_b_keys#11 := ColumnRef(type=INT64, column=$aggregate.$agg3#10)
        +-input_scan=
          +-MatchRecognizeScan
            +-column_list=$aggregate.[$agg1#6, $agg2#8, $agg3#10]
            +-input_scan=
            | +-TableScan(column_list=KeyValue.[Key#1, Value#2], table=KeyValue, column_index_list=[0, 1])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            | | +-name="A"
            | | +-predicate=
            | |   +-FunctionCall(GoogleSQL:$less(INT64, INT64) -> BOOL)
            | |     +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            | |     | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            | |     +-Literal(type=INT64, value=10)
            | +-MatchRecognizeVariableDefinition
            |   +-name="B"
            |   +-predicate=
            |     +-FunctionCall(GoogleSQL:$greater_or_equal(INT64, INT64) -> BOOL)
            |       +-FunctionCall(GoogleSQL:length(STRING) -> INT64)
            |       | +-ColumnRef(type=STRING, column=KeyValue.Value#2)
            |       +-Literal(type=INT64, value=10)
            +-pattern=
            | +-MatchRecognizePatternOperation
            |   +-op_type=CONCAT
            |   +-operand_list=
            |     +-MatchRecognizePatternVariableRef(name="A")
            |     +-MatchRecognizePatternVariableRef(name="B")
            +-after_match_skip_mode=END_OF_MATCH
            +-measure_group_list=
            | +-MeasureGroup
            | | +-aggregate_list=
            | |   +-$agg1#6 := AggregateFunctionCall(GoogleSQL:$count_star() -> INT64)
            | +-MeasureGroup
            |   +-pattern_variable_ref=
            |   | +-MatchRecognizePatternVariableRef(name="B")
            |   +-aggregate_list=
            |     +-$agg2#8 :=
            |     | +-AggregateFunctionCall(GoogleSQL:sum(INT64) -> INT64)
            |     |   +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            |     +-$agg3#10 :=
            |       +-AggregateFunctionCall(GoogleSQL:count(INT64) -> INT64)
            |         +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-match_number_column=$match_recognize.$match_number#3
            +-match_row_number_column=$match_recognize.$match_row_number#4
            +-classifier_column=$match_recognize.$classifier#5
==

# Regression test for b/394128431 where the row range info is not passed to and
# from subqueries.
# Same level, in top-level agg, pattern variable comes first
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM(b.key - (SELECT key)) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: Correlated access to MATCH_RECOGNIZE columns in the MEASURES clause is not allowed [at 4:25]
    SUM(b.key - (SELECT key)) AS m
                        ^
==

# Regression test for b/394128431 where the row range info is not passed to and
# from subqueries.
# Same level, in top-level agg, subquery comes first
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM((SELECT key) - b.key) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: Correlated access to MATCH_RECOGNIZE columns in the MEASURES clause is not allowed [at 4:17]
    SUM((SELECT key) - b.key) AS m
                ^
==

# Regression test for b/394128431 where the row range info is not passed to and
# from subqueries.
# Multilevel agg, pattern variable access in GROUP BY
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM((SELECT key) GROUP BY b.key) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: Correlated access to MATCH_RECOGNIZE columns in the MEASURES clause is not allowed [at 4:17]
    SUM((SELECT key) GROUP BY b.key) AS m
                ^
==

# Regression test for b/394128431 where the row range info is not passed to and
# from subqueries.
# Multilevel agg, subquery in GROUP BY
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES
    SUM((SELECT b.key) GROUP BY key) AS m
  PATTERN (a b)
  DEFINE
    A AS length(value) < 10,
    B AS length(value) >= 10
)
--
ERROR: Correlated access to MATCH_RECOGNIZE columns in the MEASURES clause is not allowed [at 4:17]
    SUM((SELECT b.key) GROUP BY key) AS m
                ^
==

# Regression test for b/394128431 where the row range info is not passed to and
# from subqueries.
# Like the above but for DEFINE. Currently DEFINE doesn't allow references to
# pattenr variables nor aggregation.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES 1 AS one
  PATTERN (a)
  DEFINE
    a AS (select key > 0)
)
--
ERROR: Correlated access to MATCH_RECOGNIZE columns in the DEFINE clause is not allowed [at 6:18]
    a AS (select key > 0)
                 ^
==

# WITH() expr inside DEFINE should not count as correlated access.
SELECT * FROM KeyValue MATCH_RECOGNIZE(
  ORDER BY key
  MEASURES 1 AS one
  PATTERN (a)
  DEFINE
    a AS WITH(x AS key, x > 1)
)
--
QueryStmt
+-output_column_list=
| +-$match_recognize.one#7 AS one [INT64]
+-query=
  +-ProjectScan
    +-column_list=[$match_recognize.one#7]
    +-input_scan=
      +-ProjectScan
        +-column_list=[$match_recognize.one#7]
        +-expr_list=
        | +-one#7 := Literal(type=INT64, value=1)
        +-input_scan=
          +-MatchRecognizeScan
            +-input_scan=
            | +-TableScan(column_list=[KeyValue.Key#1], table=KeyValue, column_index_list=[0])
            +-analytic_function_group_list=
            | +-AnalyticFunctionGroup
            |   +-order_by=
            |     +-WindowOrdering
            |       +-order_by_item_list=
            |         +-OrderByItem
            |           +-column_ref=
            |             +-ColumnRef(type=INT64, column=KeyValue.Key#1)
            +-pattern_variable_definition_list=
            | +-MatchRecognizeVariableDefinition
            |   +-name="a"
            |   +-predicate=
            |     +-WithExpr
            |       +-type=BOOL
            |       +-assignment_list=
            |       | +-x#3 := ColumnRef(type=INT64, column=KeyValue.Key#1)
            |       +-expr=
            |         +-FunctionCall(GoogleSQL:$greater(INT64, INT64) -> BOOL)
            |           +-ColumnRef(type=INT64, column=$with_expr.x#3)
            |           +-Literal(type=INT64, value=1)
            +-pattern=
            | +-MatchRecognizePatternVariableRef(name="a")
            +-after_match_skip_mode=END_OF_MATCH
            +-match_number_column=$match_recognize.$match_number#4
            +-match_row_number_column=$match_recognize.$match_row_number#5
            +-classifier_column=$match_recognize.$classifier#6
